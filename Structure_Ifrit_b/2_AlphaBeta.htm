<!DOCTYPE html>
<html>

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright (c) 2006-2019, Brenkman Andrey and/or its affiliates. All rights reserved. -->
<title>Alpha-beta</title>
</head>

<body>

<table border="0" cellspacing="1" width="100%" id="AutoNumber1"  bgcolor="#CCCCFF">
  <tr>
    <td width="100%">
    <table border="0" cellspacing="1" width="100%" id="AutoNumber2">
      <tr>
        <td width="*">
        <h2 align="center"><span lang="ru">Alpha-beta (Альфа-бета оптимизация полного перебора)</span></h2>
        </td>
        <td width="25%">
        <p align="center"><a href="0_0_Structure_Ifrit_b.htm">на главную страницу</a></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%">
 <br>
   
 Для начала напомню, что описание строится на основании MiniMaxa, а не NegaMaxa. 
 Я до сих пор думаю, что NegaMax мутит воду, и сокращение кода ведет к трудности 
 понимания, тестирования и падению скорости. В свое время я со скрипом перешел с 
 NegaMaxa на MiniMax и думаю что это надолго. Конечно, это часть религиозной 
 войны, и я четко обозначил свою позицию :)<br>
 Ну да ладно перейдем к алгоритму.<br>
 <br>
 int AlphaBetaWhite(int alpha, int beta, int depth)// поиск за белых<br>
 { <br>
 &nbsp;
 int tmp;<br>
 &nbsp;
 int max = -INFINITY;// устанавливаем локальный максимум в минус бесконечность<br>
 &nbsp;
 if(depth &lt;= 0) return Evaluate();// на предельной глубине считаем оценку 
 позиции<br>
 &nbsp;
 GenerateWhite ();// генерируем список ходов за белых<br>
 &nbsp;
 while(moveList) списки ходов локальные, т.е. действуют только в узле<br>
 &nbsp;
 { <br>
 &nbsp;&nbsp;&nbsp;
 MakeMoveWhite;// делаем ход<br>
 &nbsp;&nbsp;&nbsp;
 tmp = AlphaBetaBlack (alpha, beta, depth-1); <br>
 &nbsp;&nbsp;&nbsp;
 UnMakeMoveWhite;// откатываем ход<br>
 &nbsp;&nbsp;&nbsp;
 if(tmp &gt; max) max = tmp; // белые ищут локальный максимум<br>
 &nbsp;&nbsp;&nbsp;
 if(tmp &gt; alpha) alpha = tmp; // ищем усиления alpha<br>
 &nbsp;&nbsp;&nbsp;
 if(max &gt;= beta) return max; // если max &gt;= beta, то дальше перебирать 
 бесполезно, ведь в результате перебора мы будем только увеличивать<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 // max, а его черные уже считают больше, чем найденный, и этот вариант будет 
 откинут.<br>
 &nbsp;
 }<br>
 &nbsp;
 return max;<br>
 }<br>
 <br>
 int AlphaBetaBlack (int alpha, int beta, int depth)// поиск за черных<br>
 { <br>
 &nbsp;
 int tmp;<br>
 &nbsp;
 int min = INFINITY; <br>
 &nbsp;
 if(depth &lt;= 0) return Evaluate(); <br>
 &nbsp;
 GenerateBlack (); <br>
 &nbsp;
 while(moveList) <br>
 &nbsp;
 { <br>
 &nbsp;&nbsp;&nbsp;
 MakeMoveBlack;<br>
 &nbsp;&nbsp;&nbsp;
 tmp = AlphaBetaWhite (alpha, beta, depth-1); <br>
 &nbsp;&nbsp;&nbsp;
 UnMakeMoveBlack;<br>
 &nbsp;&nbsp;&nbsp;
 if(tmp &lt; min) min = tmp; // черные ищут локальный минимум<br>
 &nbsp;&nbsp;&nbsp;
 if(tmp &lt; beta) beta = tmp; //<br>
 &nbsp;&nbsp;&nbsp;
 if(min &lt;=alpha) return min; // если min &lt;=alpha то дальше перебирать бесполезно 
 ведь в результате перебора мы будем только уменьшать<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 // min, а его белые уже считают меньше чем найденный , и этот вариант будет 
 откинут.<br>
 &nbsp;
 }<br>
 &nbsp;
 return min;<br>
 }<br>
 <br>
 Alpha - это максимум белых, который был найден в проведенном до этого поиске, 
 beta - это найденный минимум черных. Следует сказать, что распространяются они 
 только вниз, т.е. в глубину поиска. Если сделать их глобальными, то схема 
 работать не будет.<br>
 Первый вызов вида AlphaBetaWhite (-INFINITY, INFINITY, DepthMax), т.е. alpha = 
 минус бесконечности, а beta = плюс бесконечности. Во время поиска белые 
 стремятся увеличить альфу, а черные уменьшить бету.<br>
 Допустим, в текущем узле ход белых. Они перебирают возможные ходы и стремятся 
 найти лучший ход, т.е. с максимальной оценкой. Текущая альфа содержит найденный 
 до этого максимум. Теперь мы порождаем узел следующей глубины, в котором уже 
 ход черных. Туда же мы передаем текущую альфу. Черные в свою очередь перебирают 
 ходы и ищут минимум. Кроме того, они сравнивают свою оценку с альфой. Если эта 
 оценка меньше альфы, то перебор можно досрочно прекратить, ведь дальнейший 
 поиск будет только уменьшать оценку, а она и так меньше альфы, т.е. будет 
 отброшена белыми. Другими словами, найденного опровержения черных уже хватает, 
 что бы белые отбросили этот ход, ведь у них есть лучший, конечно продолжая 
 поиск, черные, возможно, смогут найти ход еще лучше для них и еще более 
 неприемлемый для белых, но это будет бесполезная работа. То же самое и для 
 черных.<br>
 Сортировка ходов имеет принципиальное значение для а-б, потому что чем раньше 
 мы найдем лучший ход, тем больше будет отсечений и тем меньше надо перебирать. 
 В худшем случае, т.е. если лучший ход будет найден последним, мы получим полный 
 перебор.<br>
 Описанная мной схема, т.е. когда вверх идут оценки, а альфа с бетой только вниз 
 называется схемой с амортизацией отказов. И именно эту схему я считаю 
 корректной. Другие схемы хоть и работают, но при определенных условиях должны 
 давать сбой. Надо сказать, что я пробовал и то и другое и, честно говоря, 
 нестабильности не замечал. И все-таки, если следовать теории, то видимо нужно 
 использовать схему с амортизацией отказов. <br>
 <br>
 У а-б есть неприятная особенность. Достоверной является только оценка лучшей 
 линии и тех линий, что были рассмотрены до нахождения лучшей. Все остальные 
 обрываются досрочно и оценены слишком оптимистично для исследующей стороны. <br>
 <br>
 И еще один момент – в начале поиска alpha должна быть меньше beta<span lang="ru">,</span> иначе 
 последуют отсечки и поиска не получится. Другими словами<span lang="ru">,</span> будет вытащен первый 
 попавшийся вариант, а все остальное будет отсечено. И не важно какая оценка<span lang="ru">,</span> все 
 остальное все равно отсечет alpha или beta.<br>
 Поэтому для белых вместо<br>
 if(max &gt;= beta) return max; <br>
 можно смело писать<br>
 if(alpha &gt;= beta) return alpha; <br>
 а для черных вместо<br>
 if(min &lt;=alpha) return min;<br>
 пишем<br>
 if(alpha &gt;= beta) return beta;<br>
 <span lang="ru">З</span>десь alpha и beta используются для отсечки, и их поднятие на уровень вверх 
 никак не отражается на стабильности.<br>
 В данный момент я считаю, что эти схемы эквивалентны.<br>
 <br>
 Как можно протестировать а-б? Я считаю, что при отсутствии сортировки и 
 одинаковой глубине лучший ход, найденный а-б, должен совпадать с лучшим ходом, 
 найденным полным перебором. Ходы нельзя сортировать по той причине, что есть 
 много отличных позиций с одинаковой оценкой. Понятно, что и полный перебор и 
 а-б схватят первую попавшуюся позицию, но из-за сортировки они часто 
 оказываться разными.<br>
 <br>
 С помощью альфа-бета оптимизации можно увеличить глубину перебора максимум в 
 два раза. Так если у нас полный перебор из начальной позиции достигал за 
 секунду глубины 4-5, то при идеальной сортировке а-б позволит достичь глубины 
 8-10 (скорости перебора от 206 603 до 5 072 212 узлов в секунду)<br>
 На данный момент Ifrit_b2_5 показывает следующие результаты:<br>
 Для полного перебора:<br>
 4/4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00:00&nbsp;&nbsp;&nbsp; 197.281&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 573.897&nbsp;&nbsp; +0,07&nbsp;&nbsp; e2e4 Ng8f6 e4e5 Nf6e4<br>
 5/5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00:10&nbsp;&nbsp;&nbsp; 4.865.609&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 517.731&nbsp;&nbsp; +0,26&nbsp;&nbsp; e2e4 Ng8f6 e4e5 Nf6e4 d2d4<br>
 <br>
 Для а-б со всеми сортировками:<br>
 7/7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00:00&nbsp;&nbsp;&nbsp; 406.924&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 844.151&nbsp;&nbsp; +0,27&nbsp;&nbsp; e2e4 Ng8f6 e4e5 Nf6d5 Qd1f3 c7c6 d2d4<br>
 8/8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00:02&nbsp;&nbsp;&nbsp; 705.079&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 559.051&nbsp;&nbsp; +0,12&nbsp;&nbsp; e2e4 e7e5 Ng1f3 Ng8f6 d2d4 e5xd4 Qd1xd4 Bf8e7<br>
 9/9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00:15&nbsp;&nbsp;&nbsp; 8.484.952&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 742.262&nbsp;&nbsp; +0,29&nbsp;&nbsp; e2e4 e7e5 Ng1f3 Bf8d6 d2d4 e5xd4 Qd1xd4 Ng8f6 
 Bf1c4<br>
 10/10&nbsp; 01:33&nbsp;&nbsp;&nbsp; 34.110.652&nbsp;&nbsp;&nbsp; 564.277&nbsp;&nbsp; +0,04&nbsp;&nbsp; d2d4 d7d5 Nb1c3 Bc8f5 Bc1f4 Nb8c6 Ng1f3 
 Ng8f6 e2e3 Qd8d7<br>
 <br>
 Видно, что достигается 7 глубина при скорости ~400 kN/c. Выдаваемые скорости в 
 таблице оставлю на совести таймера. Гораздо надежнее взять количество узлов из 
 третьего столбца и поделить на время счета из второго. Эти данные надежны, а 
 вот скорость в четвертом столбце вызывает вопросы.<br>
 Идеальная сортировка не достижима и 7 для такой скорости вроде не очень плохо. 
 В любом случае, что есть - то есть. Хотя если вспомнить, что это на Core 2 Duo 
 3000 то становиться грустно. <br>
 Главное, что следует запомнить - 10 глубина за секунду перебора в начальной 
 позиции, это абсолютный потолок для а-б на современных процах.<br>
 Но что такое 10 для современных движков? Считать надо гораздо глубже, так что и 
 на а-б останавливаться никак нельзя. Это значит, что мы должны априорно решать, 
 какие ветки нам интересны и их надо бы просматривать глубже, а какие можно и 
 сократить. Самая известная эвристика - это конечно Null-move (эвристика 
 нулевого хода), но о ней в другом месте.<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</td>
  </tr>
</table>

</body>

</html>