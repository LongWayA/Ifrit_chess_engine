<!DOCTYPE html>
<html>

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright (c) 2006-2019, Brenkman Andrey and/or its affiliates. All rights reserved. -->
<title>Bitboard_representation</title>
</head>

<body>

<table border="0" cellspacing="1" width="100%" id="AutoNumber1"  bgcolor="#CCCCFF">
  <tr>
    <td width="100%">
    <table border="0" cellspacing="1" width="100%" id="AutoNumber2">
      <tr>
        <td width="*">
        <h2 align="center"><span lang="ru">Bitboard representation</span></h2>
        </td>
        <td width="25%">
        <p align="center"><a href="0_1_Bitmap_Move_Generation.htm">на главную страницу</a></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%">
<br>    
<font size="4">БИТОВОЕ ПРЕДСТАВЛЕНИЕ ДОСКИ</font><br>
<br>
<font size="4">Одномерное представление доски</font><br>
Доску мы отображаем на 64- битное число. Это означает что, каждая клетка 
представлена одним битом. Для каждой клетки возможно два состояния - 1 или 0.
<br>
<br>
Она имеет вид:<br>
(MSB) 0010…010001 (LSB)<br>
LSB – least significant bit младший бит<br>
MSB – most significant bit старший бит <br>
<br>
Мы знаем, что разряды - это степени числа 2<br>
0001 это 2 **0<br>
0010 это 2 **1<br>
0100 это 2 **2<br>
<br>
Таким образом:<br>
LSB это 2**0<br>
MSB это 2**63<br>
<br>
Но вот как это отображается в развертке?<br>
Возможно, 1 у нас запишется как 0000..001,<br>
а возможно и 1 у нас запишется как 1000..000<br>
<br>
Сдвиг влево это &lt;&lt;<br>
При его использовании самые старшие биты уходят в небытие.<br>
Значит, если опираться на графику этой операции, развертка у нас должна 
выглядеть так: <br>
1 у нас запишется как 0000..001<br>
<br>
Если еще вспомнить, что шестнадцатеричное представление у нас задается в виде:<br>
1 = 0x1<br>
16 = 0x10,<br>
то окончательно останавливаемся на развертке вида:<br>
1 как 0000..001<br>
<br>
<br>
<font size="4">Отображение доски на одномерный массив</font><br>
Доска это матрица 8 на 8. Или по-другому - это двухмерный массив. Его можно 
огромным количеством способов отобразить на одномерный массив. Для однозначности 
мы должны задать формулы отображения доски напрямую и обратно.<br>
<br>
Отображение доски напрямую задаем формулой:<br>
Line_index = 8 * Rank_index + File_index<br>
<br>
Обратное отображение прямой на доску:<br>
File_index&nbsp;&nbsp; = Line_index modulo 8 =  Line_index % 8 =&nbsp; Line_index &amp; 7<br>
Rank_index = Line_index div 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = Line_index&nbsp; 
/ 8&nbsp;&nbsp; = Line_index &gt;&gt; 3<br>
<br>
Здесь у нас:<br>
Line_index – координата одномерной доски (от 0 до 63)<br>
Rank_index – координата доски по вертикали (от 0 до 7)<br>
File_index – координата доски по горизонтали (от 0 до 7)<br>
<br>
Таким образом, доску мы представляем в виде:<br>
A8(56) B8(57) C8(58) D8(59) E8(60) F8(61) G8(62) H8(63)<br>
A7(48) B7(49) C7(50) D7(51) E7(52) F7(53) G7(54) H7(55)<br>
A6(40) B6(41) C6(42) D6(43) E6(44) F6(45) G6(46) H6(47)<br>
A5(32) B5(33) C5(34) D5(35) E5(36) F5(37) G5(38) H5(39)<br>
A4(24) B4(25) C4(26) D4(27) E4(28) F4(29) G4(30) H4(31)<br>
A3(16) B3(17) C3(18) D3(19) E3(20) F3(21) G3(22) H3(23)<br>
A2(8)&nbsp;&nbsp; B2(9)&nbsp;&nbsp; C2(10) D2(11) E2(12) F2(13) G2(14) H2(15)<br>
A1(0)&nbsp;&nbsp; B1(1)&nbsp;&nbsp; C1(2)&nbsp;&nbsp; D1(3)&nbsp;&nbsp; E1(4)&nbsp;&nbsp; F1(5)&nbsp;&nbsp; G1(6)&nbsp;&nbsp; H1(7)<br>
<br>
т.е. битовая развертка выглядит следующим образом:<br>
H8(63) G8(62) F8(61) . . . . . .C1(2) B1(1) A1(0)<br>
A1(LSB)- это нулевой бит H8(MSB)-это 63 бит<br>
<br>
Мы не только развернули доску в линию, но и развернули эту линию.<br>
<br>
<br>
<font size="4">Структура доски</font><br>
Так как бит может принимать только два значения 1 или 0, то на битовой доске мы 
можем представить только факт присутствия или отсутствия фигуры. Конечно, нам 
этого недостаточно нам нужно знать, что это за фигура и какого она цвета.<br>
<br>
Для полного описания <span lang="ru">доски </span>я использовал следующую структуру <br>
// битовая доска<br>
struct T_Bitboard {<br>
unsigned __int64 all_piece;<span lang="ru">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
в</span>се фигуры<br>
unsigned __int64 all_white_piece;<span lang="ru">&nbsp; в</span>се белые фигуры<br>
unsigned __int64 all_black_piece;<span lang="ru">&nbsp; в</span>се черные фигуры<br>
<br>
// битовые списки черных и белых фигур<br>
unsigned __int64 white_piece[NAME];<br>
unsigned __int64 black_piece[NAME];<br>
<br>
NAME это имя фигуры и оно принимает следующие значения:<br>
0 - нет фигуры<br>
1 - пешка <br>
2 - конь <br>
3 - слон<br>
4 - ладья <br>
5 - ферзь <br>
6 - король<br>
<br>
Это значит, что для каждого класса фигур своя битовая доска.<br>
<br>
Для полноты картины добавлю, что используется еще два массива, задающие имя 
фигуры от координаты:<br>
int white_name_from_coord[COORDINATE];<br>
int black_name_from_coord[COORDINATE];<br>
по ним можно моментально узнать какая фигура на данном поле стоит.<br>
<br>
//-------------------------------------------------<br>
// ВСПОМОГАТЕЛЬНАЯ ИНФОРМАЦИЯ<br>
// цвет хода 0 - черные 1 - белые<br>
int colour_move;<br>
<br>
// разрешение бития на проходе 1/0<br>
int taking_passage_yes;<br>
<br>
// х координата битого поля(конвертируем из буквы)<br>
// так а - 0 , h - 7 таким образом по х отображение прямое<br>
int taking_passage_x;<br>
<br>
// у координата битого поля<br>
// так '1' - 0 , '8' - 7 таким образом отображение тоже прямое только сдвинуто 
на 1<br>
int taking_passage_y;<br>
<br>
// рокировка белых в длинную сторону 1/0<br>
int castling_Q;<br>
<br>
// рокировка белых в короткую сторону 1/0<br>
int castling_K;<br>
<br>
// рокировка черных в длинную сторону 1/0<br>
int castling_q;<br>
<br>
// рокировка черных в короткую сторону 1/0<br>
int castling_k;<br>
<br>
// 64 битный хеш ключ позиции<br>
unsigned __int64 hash_key ;<br>
<br>
// оценка позиции<br>
int eval ;<br>
};//struct T_Bitboard {<br>
<br>
<font size="4">Расположение фигуры на доске</font><br>
Допустим, единственная фигура стоит на поле А1.<br>
Доска выглядит так:<br>
0 0 0 0 0 0 0 0<br>
0 0 0 0 0 0 0 0<br>
0 0 0 0 0 0 0 0<br>
0 0 0 0 0 0 0 0<br>
0 0 0 0 0 0 0 0<br>
0 0 0 0 0 0 0 0<br>
0 0 0 0 0 0 0 0<br>
1 0 0 0 0 0 0 0<br>
<br>
или если ее развернуть то так:<br>
0000000000000000000000000000000000000000000000000000000000000001<br>
это у нас число 1<br>
<br>
если фигура стоит на поле Н8 то:<br>
<br>
0 0 0 0 0 0 0 1<br>
0 0 0 0 0 0 0 0<br>
0 0 0 0 0 0 0 0<br>
0 0 0 0 0 0 0 0<br>
0 0 0 0 0 0 0 0<br>
0 0 0 0 0 0 0 0<br>
0 0 0 0 0 0 0 0<br>
0 0 0 0 0 0 0 0<br>
<br>
или если ее развернуть то так:<br>
1000000000000000000000000000000000000000000000000000000000000000<br>
это число 9223372036854775808<br>
<br>
В результате любому положению фигуры на доске мы можем сопоставить 64 битное 
число в диапазоне от 1 до 9223372036854775808<br>
<br>
Зная что:<br>
2**0 это 00..001<br>
2**1 это 00..010<br>
2**2 это 00..100<br>
т.е. просто бежим по степеням 2.<br>
Мы можем рассчитать массив констант для всевозможного расположения взведенного 
бита на доске.<br>
В программе это массив:<br>
<br>
const unsigned __int64 move_masks[] ={<br>
// в примечании пишем какой бит установлен в 1<br>
1, // 0 bit т.е. ....0001<br>
2, // 1 bit т.е. ....0010<br>
4, // 2 bit т.е. ....0100 <br>
8, // 3 bit и т.д.<br>
16, // 4 bit<br>
….<br>
}<br>
<br>
Таким образом, если у нас есть 64 битное число all_piece, то добавить фигуру на 
поле А1 можно следующим образом:<br>
<br>
all_piece = all_piece | 1<br>
| - or операция логического «или» работает следующим образом - если хоть одна 
единица, то результат единица.<br>
в программе это будет:<br>
all_piece = all_piece | move_masks[0] (очевидно что | move_masks[0] = 1)<br>
<br>
Стереть фигуру с позиции можно следующим образом:<br>
all_piece = all_piece ^ 1<br>
^ - xor операция исключающего или работает следующим образом, если хоть одна 
единица, то результат единица, но если обе единицы то результат ноль.<br>
В программе это будет:<br>
all_piece = all_piece ^ move_masks[0]<br>
<br>
<br>
<font size="4">Всевозможные ходы фигуры</font><br>
Следуя соглашению об отображении доски на одномерный массив и используя 
move_masks[], можно рассчитать массив ходов фигуры от ее расположения.<br>
Например, для короля на А1 это будет:<br>
<br>
Доска выглядит так:<br>
0 0 0 0 0 0 0 0<br>
0 0 0 0 0 0 0 0<br>
0 0 0 0 0 0 0 0<br>
0 0 0 0 0 0 0 0<br>
0 0 0 0 0 0 0 0<br>
0 0 0 0 0 0 0 0<br>
1 1 0 0 0 0 0 0<br>
0 1 0 0 0 0 0 0<br>
<br>
Или если ее развернуть то так:<br>
0000000000000000000000000000000000000000000000000000000110000001<br>
это будет число 770<br>
<br>
Массив всевозможных расположений и ходов для них короля в программе<br>
<br>
const unsigned __int64 king_moves_masks[] ={<br>
// в примечании пишем, где находится король, например from0 - король в A1(0)<br>
//======================<br>
770, // from0<br>
//======================<br>
1797, // from1<br>
…<br>
}<br>
<br>
Аналогично для всех фигур.<br>
<br>
Массивы возможных ходов это все ходы, которые может сделать фигура, если она 
находится одна на доске.<br>
Следует понимать, что отображение доски и массивы возможных ходов фигуры 
завязаны друг на друга. Поэтому о массивах всевозможных ходов было сказано в 
главе о структуре доски. <br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</td>
  </tr>
</table>

</body>

</html>