<!DOCTYPE html>
<html>

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 
 <title>Дневник разработчика шахматной программы часть 6</title>
</head>

<body>

<table border="0" cellspacing="10" width="100%" id="AutoNumber1"  bgcolor="#CCCCFF">
  <tr>
    <td width="100%">
    <table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber2">
      <tr>
        <td width="75%">
    <h2 align="center">Ifrit </h2>
    <h2 align="center">История разработки.</h2>
        </td>
        <td width="25%">
        <p align="left"><a href="ifrit_chess_engine.html">на главную страницу</a></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%">
      <p class="MsoNormal" align="left"><span style="font-size:14.0pt">&nbsp;<br>
      <a href="Ifrit_history_development_6.htm">Ifrit_<span lang="en-us">j</span> История разработки. <br >
      Часть 6 </a>
      </p>



<font size="4">

      <p align="left">Ifrit<br>
      Часть 7<br>
      <br>
      &nbsp;</p>
      <p>Опубликованная версия <font FACE="Times New Roman">I</font>frit_j2_0</p>
      <p>Опубликованная версия <font FACE="Times New Roman">I</font>frit_j2_1</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Среда, 18 ноября 2009 г.</p>
      <p>Продлевать ли на разменах? Это для меня тоже очень сложный вопрос. 
      Теоретически конечно нужно глубже смотреть динамику. Но на практике 
      программа застревает на этих вариантах и не успевает посмотреть 
      альтернативы, которые очень часто оказываются гораздо интереснее. </p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Четверг, 26 ноября 2009 г.</p>
      <p>Вроде бы у меня лмр(<font FACE="Times New Roman">LMR</font>) сделан 
      правильно, но он очень много пропускает. Сразу скажу, что это очень 
      классный метод и отказываться от него у меня и в мыслях нет. Просто его 
      нужно доработать. Сразу добавил учет шаха на предыдущей глубине.</p>
      <p>Продление на лучшем взятии выглядит привлекательно, но тесты 
      показывают, что программа без продлений тактику видит лучше! Точнее 
      находит тактические удары в большем количестве позиций. В общем, программа 
      с продлениями лучше в одних позициях, а без продлений в других.</p>
      <p>Как такое возможно? Все дело в том, что программа с продлениями 
      застревает на продлеваемых вариантах и не успевает посмотреть другие</p>
      <p>которые возможно лучше. Ситуацию давно описали, как хвост «вытащишь нос 
      увязнет» и наоборот.</p>
      <p>Но с нулевым и лмр разница задержки в продлениях почти неощутима. В то 
      время как с продлениями вариант гораздо устойчивей, так как продлевает 
      динамические линии. Сейчас я пока считаю, что без продлений никак нельзя.</p>
      <p>Редукция нулевого хода 4 в тактике лучше, чем 3. Это, конечно, при 
      чистом нулевом ходе.</p>
      <p>Принципиальным является вопрос, нужны ли продления вообще или 
      достаточно только сокращений линий?</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия <font FACE="Times New Roman">I</font>frit_j2_2</p>
      <p>Опубликованная версия <font FACE="Times New Roman">I</font>frit_j2_3</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Понедельник, 30 ноября 2009 г.</p>
      <font FACE="Times New Roman">
      <p>LMR</font> я переписал и выпустил версию 2.3. Главной ошибкой по-моему 
      было то, что я отсекался по оценке найденной через сокращенный поиск. 
      Понятно, что тактика от этого жестко страдала. Сейчас если у нас есть 
      отсечка, то проверяем ее без редукции. Нестабильность игры моей программы 
      меня давно угнетала, но я думал, что это из-за оценки.</p>
      <p>Кстати об оценке. Она сейчас просто примитивна. Добавление мобильности 
      резко тормозит поиск и, по-моему, совершенно не окупается. Видимо что-то я 
      делаю не так.</p>
      <p>Пришло время серьезно заняться распределением времени на поиск. Решил, 
      что в следующей версии будет нормальное распределение времени. </p>
      <p>Проблемы и задачи:</p>
      <p>1. До сих пор не понятно, что нужно продлевать и насколько.</p>
      <p>2. У меня нет уклонения от шахов и поэтому не понятно, как обнаруживать 
      единственный ответ.</p>
      <p>3. Не понятно насколько нужно рассмотрение шахов в форсированном 
      поиске.</p>
      <p>4. Надо все-таки сделать приличную оценку позиции.</p>
      <p>На этом пока, пожалуй, все :)</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Воскресенье, 13 декабря 2009 г.</p>
      <p>Для памяти под хеш-таблицу в 2 мегабайта</p>
      <p>Максимальное количество элементов в таблице 52 428</p>
      <p>Размер элемента таблицы в байтах 40</p>
      <p>Число степени 2 : 32 768</p>
      <p>Окончательное количество элементов 32 767</p>
      <p>Для памяти под хеш-таблицу в 256 мегабайта</p>
      <p>Максимальное количество элементов в таблице 6 710 886</p>
      <p>Размер элемента таблицы в байтах 40</p>
      <p>Число степени 2 : 4 194 304</p>
      <p>Окончательное количество элементов 4 194 303</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия <font FACE="Times New Roman">I</font>frit_j2_4</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 19 декабря 2009 г.</p>
      <p>При использовании оценки не улучающую альфу при включенном нулевом ходе 
      наблюдаю незначительные отклонения в оценке.</p>
      <p>Для лмр использование оценки из хеша вообще дает какой то другой счет.</p>
      <p>Да и сами эти эвристики достаточно сильно искажают оценки чистой альфа 
      беты. Надеюсь, что все дело в продлениях. Я забыл их отключить.</p>
      <p>Отключил продления.</p>
      <p>В использование оценки из хеш-таблицы в чистой альфа-бете не ведет к 
      искажению оценок. Хотя, варианты иногда могут в конце меняться.</p>
      <p>Лмр очень сильно искажает оценку и варианты.</p>
      <p>Может все дело в детекторе повторов.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия <font FACE="Times New Roman">I</font>frit_j2_5</p>
      <p>Опубликованная версия <font FACE="Times New Roman">I</font>frit_j2_6</p>
      <p>Опубликованная версия <font FACE="Times New Roman">I</font>frit_j2_7</p>
      <p>Опубликованная версия <font FACE="Times New Roman">I</font>frit_j2_8</p>
      <p>Опубликованная версия <font FACE="Times New Roman">I</font>frit_j2_9</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 27 февраля 2010 г.</p>
      <p>Достаточно давно ничего не писал. Все это время экспериментировал с 
      хеш-таблицей.</p>
      <p>Сейчас меня интересует два момента. Первый - это тестирование всех 
      эвристик. И второй - доведение до ума оценки.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Пятница, 26 марта 2010 г.</p>
      <p>Почему-то когда дело доходит до оценки, все как-то останавливается.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 10 апреля 2010 г.</p>
      <p>Опишу некоторые смутные желания по поводу исходного кода программы:</p>
      <p>Хотелось бы разделить программу на кучу независимых друг от друга 
      блоков, которые можно было бы тестировать и оптимизировать по отдельности.</p>
      <p>Хотелось бы написать достаточную систему тестов, так что бы прогнав 
      блок через нее можно было бы быть уверенным, что все работает правильно.</p>
      <p>Хотелось бы иметь достаточные критерии уровня оптимальности работы этих 
      блоков.</p>
      <p>Хочется отделить те части, которые меня устраивают от тех, что требуют 
      доработки. Но, к сожалению, на сегодня они все перемешаны. Особенно это 
      касается поиска, где все навалено и перемешано. </p>
      <p>В общем, я хотел бы выделить модули, которые уже завершены и систему 
      тестов и оптимальности к ним. Так же получить проблемные куски максимально 
      свободные от всего постороннего, что бы сосредоточится именно на них.</p>
      <p>Давно уже стало ясно, что тесты должны быть основой. Самый первый 
      вопрос заключается в написании исчерпывающих и быстрых тестах. Второй по 
      значимости является инкапсуляция, т.е. выделение независимых блоков.</p>
      <p>Особенно это касается генератора ходов. Дело в том, что я собираюсь 
      переписать его на ассемблере. Он вообще должен быть в виде внешнего 
      подключаемого модуля или библиотеки. </p>
      <p>Конечно, на первый взгляд код и так достаточно прозрачен и 
      протестирован. Но меня этот уровень не устраивает. Из-за этого я не могу 
      двигаться дальше. Для многих вещей я не вижу критериев оптимальности. 
      Функция поиска слишком перегружена.</p>
      <p>Конечно, переписывать, что-то на ассемблере это слишком круто. Для 
      начала следует выделить стабильные и законченные функции в отдельные 
      библиотеки. Я вижу дальнейшее развитие проекта, как кучу библиотек и 
      тестирующих модулей к ним.</p>
      <p>Для пользователей можно все линковать в один файл, так что им все 
      равно.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Воскресенье, 11 апреля 2010 г.</p>
      <p>Обдумал возможность использования библиотек. Они не упрощают, а 
      усложняют программу, добавляя излишнюю сложность процессу сборки и отладки 
      проекта. Вместо использования библиотек я лучше переименую модули и 
      сгруппирую их в папки внутри проекта. Это структурирует проект без 
      излишних проблем с библиотеками.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 17 апреля 2010 г.</p>
      <p>Весь март и до сих пор, т.е. практически весь апрель почти не занимался 
      проектом. Такие перерывы очень полезны для прозрачности и полноты 
      комментариев кода. Все дело в том, что за это время многое забывается и 
      смотришь на все по-новому. Становиться понятно, что многие моменты, 
      казавшиеся понятными и очевидными на деле не такие. </p>
      <p>Последнее что я делал, это перенес часть кода в динамическую 
      библиотеку. Получилось интересно, но это усложнения проекта на ровном 
      месте, поэтому отказался от этой идеи.</p>
      <p>Как я уже писал, в целом я недоволен кодом и недоволен уровнем игры 
      движка. Тем не менее, ничего конкретного и никаких определенных идей нет. 
      Недовольство имеет какой-то системный характер. По-моему недостаточная 
      инкапсуляция кода и непонятен уровень эффективности отдельных модулей.</p>
      <p>Самое смешное, что те же претензии я могу предъявить любому другому 
      исходному коду движка. Даже Фрукту. :) Конечно, все это на мой взгляд и 
      относительно моего недопонимания.</p>
      <p>Как оделить законченное от разрабатываемого и эффективное от излишнего? 
      Все это очень тесно переплетено и это мне не нравиться.</p>
      <p>Надо еще привести имена модулей к общеупотребительным. Если альфа-бета 
      алгоритм называется как-то по-другому, то ничего хорошего из этого не 
      выходит. У меня это касается модулей перебора, оценки и некоторых других.</p>
      <p>И, конечно, стоит переписать оценку.</p>
      <p>В целом же стоит все по-новому обдумать. </p>
      <p>&nbsp;</p>
      <p>Сейчас я попробую описать правила, которым должен соответствовать код.</p>
      <p>Каждая эвристика должна быть в отдельном модуле, который носит ее имя. 
      Недопустимо размазывание эвристики по нескольким модулям. Также 
      недопустимо присутствие больше одной эвристики в одном модуле.</p>
      <p>Программа должна иметь уровни функциональности, которым соответствуют 
      уровни кода. Например, полный перебор, потом альфа-бета отсечение и т.д.</p>
      <p>Следующий уровень сложности не должен искажать предыдущий. Т.е. не 
      должен, что-то в нем менять и предыдущий уровень при совместной работе не 
      должен опираться на следующий не должен встраивать в себя его переменные. 
      Следующий уровень может использовать переменные предыдущего, но не должен 
      их менять. </p>
      <p>Возможность отключения следующего уровня обязательна. Когда следующий 
      уровень отключен, то не должно оставаться никаких хвостов от него типа 
      незадействованных переменных. Ясно, что использование переменных 
      следующего уровня на предыдущем тоже недопустимо.</p>
      <p>Каждый уровень должен иметь набор тестов и критерии оценки 
      эффективности его реализации. Для этого нужно использовать описание его 
      функционала и сравнение с подобными реализациями.</p>
      <p>Пока что все. Теперь постараюсь привести код в соответствие этим 
      правилам.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Воскресенье, 18 апреля 2010 г.</p>
      <p>Второй день пытаюсь привести код в соответствие с озвученными 
      принципами. И только сейчас понимаю, сколько я успел наворотить.</p>
      <p>Совсем неудивительно, что все это мне не нравилось.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Понедельник, 19 апреля 2010 г.</p>
      <p>Почему-то я считал, что код хорошо прокомментирован. Сейчас я вижу 
      короткие и ничего не объясняющие обрывки. Это сложно назвать 
      комментариями. Надо будет дописать :)</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 24 апреля 2010 г.</p>
      <p>Выкинул все изменения, которые делал, целую неделю. Думал сначала все 
      поправлю, а потом запущу проект. Запустить его у меня не получилось. Еще 
      раз убедился, что изменения нужно делать маленькими порциями и после 
      каждого основательно тестировать программу.</p>
      <p>Чем дольше я смотрю на код, тем больше он мне не нравиться. Эти 
      глобальные объекты, конечно, здорово упрощают жизнь, но никогда не знаешь 
      в какой функции, что можешь встретить. Я ушел от глобальных переменных к 
      глобальным объектам! Именно из-за них я не могу ничего модернизировать, 
      потому что при попытке переноса функции за ней тянется хвост всяких 
      сюрпризов.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Воскресенье, 25 апреля 2010 г.</p>
      <p>Решил отказаться от классов. Классы заменил пространствами имен. Т.о. 
      структура программы почти не изменилась, а объекты в ней исчезли.</p>
      <p>Получается, что я двигаюсь в сторону ассемблера. Вопросы к коду 
      остались. Буду думать.</p>
      <p>Сегодня выложил следующую версию. </p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия <font FACE="Times New Roman">I</font>frit_j3</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Вторник, 27 апреля 2010 г.</p>
      <p>Вопросы к организации и тестированию поиска остались. Я должен быть 
      уверен, что поиск идет без ошибок и максимально эффективно.</p>
      <p>Программа должна быть максимально полно прокомментирована. Оценку нужно 
      переписать.</p>
      <p>Добавлять что-то новое, не выполнив этих требований, не имеет смысла. 
      Даже если новые методы усилят игру, мне это не интересно.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Четверг, 29 апреля 2010 г.</p>
      <p>Продолжаю обдумывать оптимальную структуру программы.</p>
      <p>Каждый функционал должен располагаться в отдельном модуле. Расползание 
      его по проекту недопустимо. Под функционалом я понимаю, например, 
      кэширование ходов, нулевой ход и т.д.</p>
      <p>Выше эта мысль звучала так: «Каждая эвристика должна быть в отдельном 
      модуле, который носит ее имя. Недопустимо размазывание эвристики по 
      нескольким модулям. Также недопустимо присутствие больше одной эвристики в 
      одном модуле.»</p>
      <p>Каждому модулю соответствует свое пространство. Раньше это был класс. 
      Но я ушел от классов, потому что думаю в дальнейшем оптимизировать 
      ассемблерный код. К тому же, вероятно, часть кода в начале засуну в 
      библиотеки. Классы мешают всему этому. В целом я постарался сохранить дух 
      объектного программирования, уйдя от сложностей классовой реализации.</p>
      <p>Модули и функции в них должны быть хорошо описаны. К сожалению, пока 
      это не так.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия <font FACE="Times New Roman">I</font>frit_j3_1</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Среда, 5 мая 2010 г.</p>
      <p>Пересмотрел всю программу. К сожалению самых главных вопросов так и не 
      решил. </p>
      <p>Первой задачей является тестирование поиска. Так, чтобы быть уверенным, 
      что поиск правильный.</p>
      <p>Второй задачей является переписать оценку.</p>
      <p>Модуль поиска слишком сложный. Видимо, его надо разделить на несколько 
      подмодулей. Так же что-то надо делать с эвристиками поиска типа нулевого 
      хода, лмр и т.д. Сейчас у меня все в куче в одном модуле.</p>
      <p>
      ______________________________________________________________________________________________</p>
      <p>Суббота, 8 мая 2010 г.</p>
      <p>Все эти дни не прикасался к коду.</p>
      <p>Надо сказать, что рефакторинг несколько затянулся. Следует в очередной 
      раз повысить силу игры программы. Потому что просто шлифовать код, не 
      усиливая игры тоже достаточно глупо. Ценность движка пропорциональна силе 
      его игры, поэтому не имеет смысл комментировать и оттачивать код слабого 
      движка.</p>
      <p>Слабость движка может быть по двум причинам. Плохой поиск или плохая 
      оценка. Плохой, значит, либо есть ошибки, либо недостаточно быстрый, либо 
      не реализованы какие-то важные эвристики.</p>
      <p>В первую очередь нужно поработать с поиском.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Понедельник, 10 мая 2010 г.</p>
      <p>Объектно-ориентированное программирование очень сильная техника. 
      Поэтому надо объяснить, почему я отказался от классов. </p>
      <p>Первое - это скорость. Все-таки объектные программы немного медленнее. 
      Ну и главное - это оптимизация кода на ассемблере. На нем и так код 
      слишком сложен, так что дополнительная сложность от реализации объектов 
      совсем ни к чему.</p>
      <p>Пространство имен позволило соорудить что-то похожее на абстрактные 
      классы. К тому же это оправдание в пользу Си++. :)</p>
      <p>Как тестировать поиск? Как оценивать его эффективность? Это главные 
      вопросы.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Вторник, 11 мая 2010 г.</p>
      <p>Сегодня до меня дошло, что код прокомментирован плохо. Так получилось, 
      что комментировал я в основном то, с чем больше всего возился, а 
      работающие и устойчивые модули как-то забросил. В принципе это 
      естественно, но сейчас нужно исправить этот недостаток.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия <font FACE="Times New Roman">I</font>frit_j3_2</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Воскресенье, 30 мая 2010 г.</p>
      <p>Две недели редактировал код, внедряя новый стиль отступов. К моему 
      удивлению объем кода гораздо больше чем я думал. Сейчас код стал выглядеть 
      гораздо приятнее. Однако очевидно, что где-то добавлены неожиданные 
      ошибки.</p>
      <p>Самые главные проблемы - это нормальные комментарии и полное 
      тестирование кода. </p>
      <p>Функция поиска слишком сложная. Статическая оценка непонятная, надо 
      переписывать.</p>
      <p>Продления на разменах отключил. Отношение к ним у меня неоднозначное. В 
      одних позициях они помогают, а в других мешают.</p>
      <p>Дальше буду комментировать, тестировать и исправлять выявленные 
      недоработки. </p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Понедельник, 14 июня 2010 г.</p>
      <p>Конечно, я постоянно повторяюсь. Но это потому, что мне не удается 
      решить поставленные задачи.</p>
      <dir>
        <dir>
          <p>1. Уже давно ясно, что необходимо переписать оценку. Но до сих пор 
          я так это и не сделал.</p>
          <p>2. Функция поиска слишком сложная и необозримая. Упростить ее у 
          меня не получается.</p>
          <p>3. Уровень тестирования недостаточный. Но на данный момент я не 
          знаю, как протестировать нулевой ход, лмр и т.д.</p>
          <p>4. Уровень инкапсуляции недостаточный. И тут есть о чем подумать.</p>
          <p>5. Комментарии недостаточно понятны. Следует их дополнить.</p>
        </dir>
      </dir>
      <p>Давно уже ясно, что подключение новых эвристик не должно искажать 
      предыдущий код. Переменные, используемые эвристиками, должны отключаться 
      вместе с ними. К сожалению в случае параметров функций у меня не 
      получается реализовать это правило.</p>
      <p>Идеалом служат предельно простые и изолированные фрагменты кода, для 
      которых есть всеохватывающие тесты. Лучше всего сделать код 
      самотестируемым.</p>
      <p>Задачи ясны. Теперь не буду выпускать следующих версий, если не решен 
      хотя бы один пункт.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Среда, 16 июня 2010 г.</p>
      <p>Уже очень долгое время я не добавляю никаких новых эвристик. На самом 
      деле я все еще не могу разгрести то, что уже сделал. Хочется сделать 
      максимально прозрачный код с максимальной надежностью. На этом я и 
      застрял.</p>
      <p>Надо будет добавить внятные описания и на уровне модуля и на уровне 
      функций. Следует добавить описание алгоритма работы функций -</p>
      <p>это совершенно необходимый этап. Без него смешно говорить о пригодности 
      кода для людей, которые только постигают шахматное программирование. 
      Честно говоря, не очень понятно, почему я раньше не озаботился этой 
      проблемой.</p>
      <p>Все должно быть максимально просто и понятно.</p>
      <p>Особенно меня не устраивает функция поиска. Слишком она наворочена. </p>
      <p>Главным вопросом остается, конечно, максимально полное тестирование.</p>
      <p>Еще надо будет понять, почему Ифрит играет только на 2100. Что ему 
      мешает дойти хотя бы до 2800. </p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Пятница, 18 июня 2010 г.</p>
      <p>Больше всего меня заботит вопрос тестирования. Должно быть так, чтобы, 
      тщательно протестировав эвристику, можно было бы к ней не возвращаться. 
      Чтобы другие части никак не влияли на уже проверенные. Чтобы включение 
      новых эвристик не искажало старых.</p>
      <p>Плюс еще эвристики должны быть самотестируемыми, что бы в случае 
      неправильной работы они сами об этом говорили. Конечно, это тесты должны 
      быть отключаемыми. Они нужны только во время разработки.</p>
      <p>Вероятно, тесты стоит поместить в отдельные тестовые модули. Чтобы они 
      были обозримыми и не смешивались с основными функциями.</p>
      <p>Тестов можно придумать огромное количество, и они существенно засорят 
      код. Т.о. вопрос считаю решенным.</p>
      <p>На данный момент задачей является тестирование и описывание эвристик. Я 
      должен получить гарантию, что они работают правильно и плюс еще они должны 
      быть максимально простыми и понятными.</p>
      <p>Вопрос тестирования на данный момент все еще для меня неразрешим.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 19 июня 2010 г.</p>
      <p>Максимально просто и протестировано. Плюс полное описание всех функций.</p>
      <p>Я до сих пор почти не тестировал нулевой ход и вообще не тестировал лмр. 
      Причем я даже не знаю, как это сделать.</p>
      <p>Не вижу, как тестировать форсированный поиск.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Вторник, 22 июня 2010 г.</p>
      <p>Тестирую статический поиск.</p>
      <p>В начале просто игра на глубине один с выводом всех ходов. Дальше буду 
      сравнивать с другими движками.</p>
      <p>Даже правильный статический поиск может проигрывать фигуру. Это 
      происходит в случае, когда при взятии атакуются две более ценные фигуры, 
      причем фигура агрессор защищена. И, конечно, очевидный пример - это взятие 
      с атакой и шахом защищенной малоценной фигурой.</p>
      <p>&nbsp;</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия <font FACE="Times New Roman">I</font>frit_j3_3</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Воскресенье, 4 июля 2010 г.</p>
      <p>Удалил <font FACE="Times New Roman">futility</font>
      <font FACE="Times New Roman">pruning</font>. Эвристика была отключена 
      очень долгое время. Решил убрать, чтобы не мешалась. Когда понадобиться 
      добавлю по новой.</p>
      <p>Удалил продления на разменах. Поиск надолго зависал в некоторых 
      позициях, что отрицательно сказывалось на общей картине. Решил обойтись 
      пока без него.</p>
      <p>Переписал оценку. Исправил ошибку в <font FACE="Times New Roman">lmr</font>. 
      Переменная, лимитирующая поиск без сокращения, была глобальной. В итоге в 
      некоторых узлах резались взятия, а в других продлевались тихие ходы.</p>
      <p>Оценку тщательно протестировал. Нашел кучу ошибок. Протестировал 
      статический поиск. Слегка подправил <font FACE="Times New Roman">delta</font>
      <font FACE="Times New Roman">pruning</font>.</p>
      <p>В оценке очень не хватает атаки на короля. И не хватает мобильности. 
      Надо будет обязательно добавить.</p>
      <p>Реализованное распределение времени очень слабое. Слишком быстро ходит. 
      К тому же, почему-то не чувствует добавления времени.</p>
      <p>Может быть стоит написать уклонения при шахе. Это нужно для реализации 
      продления на единственном ответе а, кроме того, должно ускорить поиск. С 
      тестированием тут проблем не будет.</p>
      <p>В остальном вроде нормально. Дальше буду тестировать, и писать 
      комментарии. Ну, это процесс перманентный. :)</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия <font FACE="Times New Roman">I</font>frit_j3_4</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Вторник, 13 июля 2010 г.</p>
      <p>Переписал распределение времени. Сила игры остается примерно на одном 
      уровне. Это уже неприемлемо. Следующую версию выпущу только в том случае, 
      если она будет примерно на сто пунктов сильнее текущей. Итак, либо 
      следующая версия будет сильнее, либо ее вообще не будет.</p>
      <font FACE="Courier New CYR" SIZE="2">
      <p>&nbsp;</p>
      </font>

      <p align="left">
      <br>
      <br>
&nbsp;</p>
      <p align="left">&nbsp;<p align="left">&nbsp;<p align="left">&nbsp;<p align="left">&nbsp;<p align="left"><br>
      <br>
&nbsp;</tr>
</table>
<p align="left">&nbsp;</p>
</font>
</body>