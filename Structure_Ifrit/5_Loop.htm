<!DOCTYPE html>
<html>

<head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<!-- Copyright (c) 2006-2019, Brenkman Andrey and/or its affiliates. All rights reserved. -->
<title>Модуль перебора</title>
</head>

<body>

<table border="0" cellspacing="1" width="100%" id="AutoNumber1"  bgcolor="#CCCCFF">
  <tr>
    <td width="100%">
    <table border="0" cellspacing="1" width="100%" id="AutoNumber2">
      <tr>
        <td width="*">
        <h2 align="center"><span lang="ru">Модуль перебора</span></h2>
        </td>
        <td width="25%">
        <p align="center"><a href="0_Structure_Ifrit.htm">на главную страницу</a></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%">
 Модуль перебора.<br>
 Начальная глубина у нас - 0. Начальная максимальная глубина у нас - 1. <br>
 Если глубина предельная, то мы статически оцениваем позицию и возвращаем оценку. 
 Причем, статический оценщик у нас абсолютный. Т.е. он преимущество белых 
 отмечает как &quot; +&quot;, а черных как &quot;-&quot;. Но мы оценку инвертируем в зависимости от того, 
 кто ходит. Это нужно для негамакса.<br>
 Тут есть тонкий момент. Мы оцениваем уже схоженную позицию. Т.е., если например 
 ходили белые, то позиция в оценщик придет с флагом &quot;ход черных&quot;.<br>
 Вообще-то мы при ходе белых оценку инвертировать не должны, но так как мы имеем 
 уже схоженную позицию, то и инвертируем именно при ходе белых.<br>
 <br>
 Запись варианта.<br>
 Когда погружаемся в вариант, на каждой глубине записываем, откуда и куда фигура 
 ходила. Таким образом, у нас получается текущий массив ходов. В случае, если мы 
 считаем, что оценка нам подходит мы записываем вариант. Причем, записываем от 
 текущей до предельной глубины. Записываем лучший вариант во временный массив, по-новой создаваемый для каждого узла. Когда же мы выходим из узла, мы вновь 
 скидываем вариант в текущий массив ходов.<br>
 Вероятно, объяснение туманное, но если посмотреть код, то все станет понятным. <br>
 <br>
 Альфа бета.<br>
 Если альфа больше локальной оценки, то записываем ее в альфу.<br>
 Если бета больше или равна альфа, то выходим возвращая бету.<br>
 В функцию передаем альфу и бету, причем, меняя их местами и со знаком &quot;минус&quot;.<br>
 Локальную оценку тоже принимаем со знаком &quot;минус&quot;.<br>
 В начале альфа максимально большая, а бета - максимально маленькая. <br>
 <br>
 Итак, мы ищем локальный минимум и если он уже меньше минимума в предыдущем 
 более высоком
 узле, поиск бросаем, так как в дальнейшем локальный минимум будет только 
 уменьшаться, а мы уже знаем,
 что его отбросим. <br>
 Тут слегка все путает негомакс, но если поднапрячься и посмотреть исходники, то 
 врубиться можно.<br>
 <br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</td>
  </tr>
</table>

</body>

</html>