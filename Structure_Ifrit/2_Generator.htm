<!DOCTYPE html>
<html>

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright (c) 2006-2019, Brenkman Andrey and/or its affiliates. All rights reserved. -->
<title>Генератор списка ходов</title>
</head>

<body>

<table border="0" cellspacing="1" width="100%" id="AutoNumber1"  bgcolor="#CCCCFF">
  <tr>
    <td width="100%">
    <table border="0" cellspacing="1" width="100%" id="AutoNumber2">
      <tr>
        <td width="*">
        <h2 align="center"><span lang="ru">Генератор списка ходов</span></h2>
        </td>
        <td width="25%">
        <p align="center"><a href="0_Structure_Ifrit.htm">на главную страницу</a></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%">
 Генератор избыточных ходов.<br>
 Данные:<br>
 <br>
 // список возможных ходов 1501<br>
 struct T_list_possible_moves {<br>
 // имя фигуры 1- пешка; 2- ладья; 3- конь; 4- слон; 5- ферзь; 6- король <br>
 int name_figure[300];<br>
 // начальное положение фигуры(откуда фигура ходит)<br>
 int initial_position[300]; <br>
 // конечное положение фигуры(куда фигура ходит)<br>
 int final_position[300];<br>
 // является ли ход ходом - 0, взятием - 1, взятием на проходе - 2, рокировкой - 3,<br>
 // превращением - 4, превращением с взятием - 5<br>
 int description_move[300];<br>
 // имя взятой фигуры: 1- пешка; 2- ладья; 3- конь; 4- слон; 5- ферзь; 6- король <br>
 int name_taking_figure[300];<br>
 // флаг возврата взятия на проходе<br>
 int return_taking_passage;<br>
 // флаг рокировки белых в длинную сторону<br>
 int return_castling_Q;<br>
 // флаг рокировки белых в короткую сторону<br>
 int return_castling_K;<br>
 // флаг рокировки черных в длинную сторону<br>
 int return_castling_q;<br>
 // флаг рокировки черных в короткую сторону<br>
 int return_castling_k;<br>
 // количество ходов в списке<br>
 int amount_moves;<br>
 };<br>
 <br>
 // полная доска реализующая принцип 8 на 16<br>
 struct T_board_list_816 {<br>
 // цвет хода<br>
 int colour_move;<br>
 // содержит имена фигур: 0 - нет фигуры, 1 - пешка, 2 - ладья, 3 - конь, 4 - слон, 
 5 - ферзь, 6 - король, 9 - выход за пределы доски<br>
 int name_figure_816[129];<br>
 // содержит цвет фигур: 1 - белые, 2 - черные, 3 - выход за пределы доски<br>
 int colour_figure_816[129];<br>
 // разрешение взятия на проходе 1/0<br>
 int taking_passage_yes;<br>
 // х координата битого поля (конвертируем из буквы) <br>
 int taking_passage_x;<br>
 // у координата битого поля (у нас инверсная относительно нормальной доски) <br>
 int taking_passage_y;<br>
 // рокировка белых в длинную сторону<br>
 int castling_Q;<br>
 // рокировка белых в короткую сторону<br>
 int castling_K;<br>
 // рокировка черных в длинную сторону<br>
 int castling_q;<br>
 // рокировка черных в короткую сторону<br>
 int castling_k;<br>
 };<br>
 <br>
 Доска представлена следующим массивом:<br>
 0&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 3&nbsp; 4&nbsp;&nbsp; 5&nbsp;&nbsp; 6&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp; 9&nbsp;&nbsp; 10 11 12 13 14 15 <br>
 16 17 18 19 20 21 22 23&nbsp; 24 25 26 27 28 29 30 31 <br>
 32 33 34 35 36 37 38 39&nbsp; 40 41 42 43 44 45 46 47 <br>
 48 49 50 51 52 53 54 55&nbsp; 56 57 58 59 60 61 62 63 <br>
 64 65 66 67 68 69 70 71&nbsp; 72 73 74 75 76 77 78 79 <br>
 80 81 82 83 84 85 86 87&nbsp; 88 89 90 91 92 93 94 95 <br>
 96 97 98 99 00 01 02 03&nbsp; 04 05 06 07 08 09 10 11 <br>
 12 13 14 15 16 17 18 19&nbsp; 20 21 22 23 24 25 26 27 <br>
 8 на 16 = 128<br>
 x = 0..7 n&amp;15 или n/16<br>
 y = 0..7 n&gt;&gt;4 или n%16<br>
 n = y*16 + x<br>
 <br>
 Generator_possible_moves(T_list_possible_moves * 
 list_possible_moves,T_board_list_816 board_list_816)<br>
 Генератор получает текущую позицию и выдает список возможных ходов.<br>
 В генераторе просто бежим по доске и вызываем блок правил для фигур ходящей 
 стороны.<br>
 <br>
 Вся работа проводится в блоке правил:<br>
 Rules_816(int name,int n,T_board_list_816 board_list_816,T_list_possible_moves 
 * list_possible_moves)<br>
 Блок правил получает имя фигуры, ее координату, текущую позицию и выдает список 
 возможных ходов<br>
 для данной фигуры.<br>
 <br>
 В блоке правил в список возможных ходов записываем:<br>
 -
 имя фигуры;<br>
 -
 начальное положение фигуры;<br>
 -
 конечное положение фигуры;<br>
 -
 описатель типа хода;<br>
 -
 количество ходов.<br>
 <br>
 Причем, имя фигуры не используется в реализаторе, оно только для тестового 
 вывода.<br>
 <br>
 В описателе типа хода записываем:<br>
 является ли ход ходом - 0, взятием - 1, взятием на проходе - 2, рокировкой - 3, 
 превращением - 4, превращением с взятием - 5.<br>
 Может тут надо будет что то уточнить? Дальше посмотрим.<br>
 <br>
 Ладья, конь, слон, ферзь - генерируют либо просто ход, либо взятие. Используется 
 способ лучей. Мы просто бежим по массиву цвета в нужном направлении, пока не 
 натыкаемся на фигуру, если она чужая мы ее бьем. Одновременно заполняем списки 
 возможных ходов. <br>
 <br>
 Вывод тестовой информации по блоку правил производиться в файл 
 &quot;f_Test_Rules_816.txt&quot;.<br>
 <br>
 Очевидно, что при таком методе, т.е. при передаче списка ходов из 
 генератора в реализатор, переход на битбоард, видимо, либо вообще не даст прироста, 
 либо даст очень маленький, а возможно вообще будет не прирост, а замедление из-за 
 многочисленных извлечений по маске.<br>
 <br>
 Ход короля мы обязаны проверять на шах. Значит, совершенно необходим детектор 
 шахов. 
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</td>
  </tr>
</table>

</body>

</html>