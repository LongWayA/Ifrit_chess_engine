#include "a_Structure.h"
#include "a_Chess_bitboard.h"

#define TEST_P 0 // включаем-выключаем(1-0)  режим вывода в файл тестовой информации
// не забываем что надо включить и печать битбоарда(bit board) TEST_B в файле d_Bitboard_gen.h TEST_B

// имя и дата выпуска версии
#define NAME_OF_PROGRAM_AND_DATA_OF_RELEASE "id name Ifrit_j3_9_Beta_12_12_2010"

//-----------------------------------------------------------------------------------
/* ++
 * АВТОР Бренкман Андрей (Brenkman Andrey)
 * ПОСЛЕДНЕЕ ИЗМЕНЕНИЕ 12.06.2007  11.11.2009
*/
//-----------------------------------------------------------------------------------

/*
 УРОВЕНЬ МОЕГО ДОВЕРИЯ 70%

 обрабатываем строки в рамках протокола UCI

 разбираем входящие UCI команды от графической шахматной оболочки
 основными тут являются две направления
 они друг с другом связанны только через представление доски bitboard(bit board) 
 т.е. фактически независимы друг от друга
 в первом мы инициализируем движок согласно заданной позиции
 // разбираем входящую позицию инициализируем внутреннюю доску движка   
    parse_position
 результатом является только доска  bitboard(bit board) 

 а во втором мы запускаем движок на обдумывание
 // запускаем движок на расчет позиции
    parse_go
 в результате в поток выводим ход и вариант

 конечно представление доски должно быть согласованно 
 оно описано в файле a_Chess_bitboard.h
*/

class Protocol_UCI
{

//
//////////////////////////////////////////////////////////////////////////////////////////
public:

	// разбираем входящие UCI команды от графической шахматной оболочки
	void parse_protokol_UCI
	(
		class Chess_bitboard * p_bitboard,//доска 
		__int8 string_in[]//входящая строка
	);


//////////////////////////////////////////////////////////////////////////////////////
private:

	//-----------------------------------------------------------------------------------
	// считывает в строке и выдает размер хеша в мегабайтах
	unsigned __int16 read_hash_size_Mb
	(
		const __int8 string_in[]
	);

};


