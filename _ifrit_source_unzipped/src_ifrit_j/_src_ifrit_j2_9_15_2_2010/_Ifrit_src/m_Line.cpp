#include "m_Line.h"

//-----------------------------------------------------------------------------------
/*
 * запись линии варианта
 *
 * АВТОР ChessTerminator75
 * ПОСЛЕДНЕЕ ИЗМЕНЕНИЕ 27.02.2009
 *
 *  ТЕСТИРОВАНИЕ
*/
//---------------------------------------------------------------------------


//	===================================================================
// обновляем линию лучшего варианта в узле
void PVSAVE::Update_PV_best_point(struct T_PV * const p_PV_best_point// лучший вариант найденный в узле
						          ){

// лучший вариант который функция перебора выдает наверх содержится в структуре PV_best
// мы не только присваиваем оценку но и вариант соответствующий ей
// присвоение идет структуре уникальной для каждого узла PV_best_point
// здесь мы перезаписываем лучший вариант соответствующий лучшей оценке
 for(unsigned __int8 n = 0; n < pv_best.depth_max; n++){
    p_PV_best_point->move[n] = pv_best.move[n];
 }//for (int n = 0; n < PV_best.depth_max; n++){

 p_PV_best_point->score_move = pv_best.score_move;
 p_PV_best_point->depth_max = pv_best.depth_max;

}//void PVSAVE::Update_PV_best_point
//	*******************************************************************

//	===================================================================
// обновляем линию лучшего варианта
void PVSAVE::Update_PV_best(const struct T_PV * const p_PV_best_point// лучший вариант найденный в узле
					        ){

// мы пробежали весь список и теперь в структуре PV_best_point содержится лучшая линия
// теперь мы ее скопируем в структуру PV_best что бы передать на более высокий уровень
  for(unsigned __int8 n = 0; n < p_PV_best_point->depth_max; n++){

     pv_best.move[n] = p_PV_best_point->move[n];

  }//for(int n = 0; n < p_PV_best_point->depth_max; n++){

  pv_best.score_move = p_PV_best_point->score_move; 
  pv_best.depth_max = p_PV_best_point->depth_max;

}//void PVSAVE::Update_PV_best
//	*******************************************************************

//	===================================================================
// обновляем линию лучшего варианта на максимальной глубине
void PVSAVE::Update_PV_best_max_depth(const __int32 & score,// оценка позиции в конце варианта
							          const unsigned __int8 & depth// текущая глубина
							          ){

// мы достигли предельной глубины и статически оценили получившуюся позицию
// погружаясь на глубину мы на каждом полу ходе заносили ходы варианта в структуру PV_current
// теперь мы перепишем его в структуру PV_best и прицепим оценку позиции
// у нас получился вариант приводящий к данной позиции и плюс оценка этой позиции
// ну и еще конечно длина варианта
// внимание тут цикл идет от 0 до Depth - 1
// именно так ведь у нас начальная глубина 0
 for(unsigned __int8 n = 0; n < depth; n++){

    pv_best.move[n] = pv_current.move[n];

 }//for(int n = 0; n < depth; n++){

 pv_best.score_move = score;

 // запоминаем глубину варианта
 pv_best.depth_max = depth;

}//void PVSAVE::Update_PV_best_max_depth
//	*******************************************************************

//	===================================================================
// записываем ход в текущий вариант
void PVSAVE::Update_PV_current(const unsigned __int8 & i,// номер хода в списке ходов
					           const unsigned __int8 & depth,// текущая глубина
					           const struct T_list_surplus_moves * const p_list_surplus_moves// список ходов
					           ){

// из списка возможных ходов копируем текущий ход в текущий вариант на текущей глубине.
// мы видим что текущий вариант прописывается до рекурсивного вызова функции Alpha_beta т.е. 
// мы разматываем нить погружаясь в глубину 
// запись в структуре PV_current верна сверху и до текущей глубины 
// то что расположено ниже данного уровня не правильно так как относится к предыдущему узлу.
pv_current.move[depth] = p_list_surplus_moves->move[i];

}//void PVSAVE::Update_PV_current
//	*******************************************************************

//	===================================================================
// возвращаем лучший вариант
struct T_PV * PVSAVE::get_pv_best(){

 return & pv_best;

}//
//	*******************************************************************

//	===================================================================
// возвращаем текущий вариант
struct T_PV * PVSAVE::get_pv_current(){

return & pv_current;

}//
//	*******************************************************************








