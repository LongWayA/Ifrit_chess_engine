#include <fstream>  // TEST
#include <iostream> // TEST
//#include <stdlib.h>

#include "List_surplus_moves.h"

//---------------------------------------------------------------------------
/*
 * АВТОР Бренкман Андрей (Brenkman Andrey)
 * ПОСЛЕДНЕЕ ИЗМЕНЕНИЕ  20.11.2010
*/
//---------------------------------------------------------------------------

/*
   УРОВЕНЬ МОЕГО ДОВЕРИЯ 

*/

//	===================================================================
// полная сортировка
void List_surplus_moves::sorting_moves()
{
	__int32 move_s;// используем для запоминания хода
	__int32 score_s;// используем для запоминания оценки хода
	//unsigned __int8 end_captures = end_captures;//количество взятий
	//unsigned __int8 end_list = end_list;//количество ходов

	/*
	список у нас начинается с 0 и имеет вид
	0 взятие
	1 взятие
	2 взятие
	3 ход          end_captures
	т.е. количество взятий на 1 превышает реальный индекс последнего взятия
	4 ход
	5 ход
	6 ход
	7              end_list
	получается что у нас настоящее количество взятий и ходов т.е. если считать с 1

	счетчик взятий и ходов в списке генератор взятий изначально ставит в ноль

	*/

	// 1 сортируем взятия----------------------------------
	/*
	если у нас есть взятия тогда мы их сортируем по оценке обсчитанной еще в генераторе взятий
	идем по списку и сравниваем(меньше ли она) текущую строку со всеми нижестоящими
	понятно что если у нас текущая строка k то следующая строка будет k + 1
	если такая(т.е. больше текущей) строка нашлась то мы меняем местами ее и текущую строку
	таким образом когда мы доходим до конца все взятия у нас отсортированы по убывающей.
	*/
	for (unsigned __int8 k = 0; k < end_captures; k++)
	{	
		for (unsigned __int8 i = k + 1; i < end_captures; i++)
		{
			if (sorting_score[k] < sorting_score[i])
			{ 
				//сохраняем данные   
				move_s = move[k];
				score_s = sorting_score[k];

				//копируем из i в k
				move[k] = move[i];
				sorting_score[k] = sorting_score[i];

				//восстанавливаем запись
				move[i] = move_s;
				sorting_score[i] = score_s;
			}
		}
	}

}

//	===================================================================
// полная сортировка корневого списка
void List_surplus_moves::sorting_white_moves_root()
{
	__int32 move_s;// используем для запоминания хода
	__int32 score_s;// используем для запоминания оценки хода
	//unsigned __int8 end_captures = end_captures;//количество взятий
	//unsigned __int8 end_list = end_list;//количество ходов


	/*
	список у нас начинается с 0 и имеет вид
	0 взятие
	1 взятие
	2 взятие
	3 ход          end_captures
	т.е. количество взятий на 1 превышает реальный индекс последнего взятия
	4 ход
	5 ход
	6 ход
	7              end_list
	получается что у нас настоящее количество взятий и ходов т.е. если считать с 1

	счетчик взятий и ходов в списке генератор взятий изначально ставит в ноль
	*/

	// 1 сортируем корневые ходы----------------------------------
	/*
	мы их сортируем по оценке обсчитанной на предыдущей итерации
	идем по списку и сравниваем(меньше ли она) текущую строку со всеми нижестоящими
	понятно что если у нас текущая строка k то следующая строка будет k + 1
	если такая(т.е. больше текущей) строка нашлась то мы меняем местами ее и текущую строку
	таким образом когда мы доходим до конца все ходы у нас отсортированы по убывающей.
	*/
	for (unsigned __int8 k = 0; k < end_list; k++)
	{	
		for (unsigned __int8 i = k + 1; i < end_list; i++)
		{
			if (sorting_score[k] < sorting_score[i])
			{ 
				// сохраняем данные   
				move_s = move[k];
				score_s = sorting_score[k];

				// копируем из i в k
				move[k] = move[i];
				sorting_score[k] = sorting_score[i];

				// восстанавливаем запись
				move[i] = move_s;
				sorting_score[i] = score_s;
			}
		}
	}

}

//	===================================================================
// полная сортировка корневого списка
void List_surplus_moves::sorting_black_moves_root()
{
	__int32 move_s;// используем для запоминания хода
	__int32 score_s;// используем для запоминания оценки хода
	//unsigned __int8 end_captures = end_captures;//количество взятий
	//unsigned __int8 end_list = end_list;//количество ходов


	/*
	список у нас начинается с 0 и имеет вид
	0 взятие
	1 взятие
	2 взятие
	3 ход          end_captures
	т.е. количество взятий на 1 превышает реальный индекс последнего взятия
	4 ход
	5 ход
	6 ход
	7              end_list
	получается что у нас настоящее количество взятий и ходов т.е. если считать с 1

	счетчик взятий и ходов в списке генератор взятий изначально ставит в ноль
	*/

	// 1 сортируем корневые ходы----------------------------------
	/*
	мы их сортируем по оценке обсчитанной на предыдущей итерации
	идем по списку и сравниваем(меньше ли она) текущую строку со всеми нижестоящими
	понятно что если у нас текущая строка k то следующая строка будет k + 1
	если такая(т.е. больше текущей) строка нашлась то мы меняем местами ее и текущую строку
	таким образом когда мы доходим до конца все ходы у нас отсортированы по убывающей.
	*/
	for (unsigned __int8 k = 0; k < end_list; k++)
	{	
		for (unsigned __int8 i = k + 1; i < end_list; i++)
		{
			if (sorting_score[k] > sorting_score[i])
			{ 
				// сохраняем данные   
				move_s = move[k];
				score_s = sorting_score[k];

				// копируем из i в k
				move[k] = move[i];
				sorting_score[k] = sorting_score[i];

				// восстанавливаем запись
				move[i] = move_s;
				sorting_score[i] = score_s;
			}
		}
	}
}