#include "a_Structure.h"
#include "a_Chess_bitboard.h"

#define TEST_H 0 // включаем-выключаем(1-0) режим вывода в файл тестовой информации

//---------------------------------------------------------------------------
/*
 * АВТОР Бренкман Андрей (Brenkman Andrey)
 * СОЗДАН 2.05.10
 * ПОСЛЕДНЕЕ ИЗМЕНЕНИЕ
*/
//---------------------------------------------------------------------------

/*
 УРОВЕНЬ МОЕГО ДОВЕРИЯ 50%

 реализуем ZObrist-ключи
*/

// этот макрос прикольный но как он вписывается в мое правило кодирования??
// а правило у меня такое - никаких макросов!!!
#define U64(u) (u##ui64)

namespace ZOBRIST
{
	// РАБОТА С ХЕШ - КЛЮЧОМ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	//---------------------------------------------------------------------------
	// каждой возможной позиции каждой возможной фигуры 
	// присваиваем случайное число
	void public_ini_random_piese_key();

	//---------------------------------------------------------------------------
	// инициализируем ключ начальной позиции
	void public_start_position_random_key
	(
		class Chess_bitboard * p_bitboard// представление доски
	);

	//---------------------------------------------------------------------------
	// меняем ключ во время хода
	void public_modification_random_key
	(
		bool  colour_figure,// цвет ходящей стороны
		unsigned __int8 i,// номер хода по списку
		class List_surplus_moves * p_list_surplus_moves,// список ходов
		class Chess_bitboard * p_bitboard,// представление доски
		struct T_undo undo[]//информация для отката хода
	);

	//////////////////////////////////////////////////////////////////////////////////////////

	//---------------------------------------------------------------------------
	// генерируем случайный 64 битный ключ
	unsigned __int64 rand_64();



	// ПОВТОРЫ ПОЗИЦИЙ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	//---------------------------------------------------------------------------
	// возвращаем количество ходов в строке игры переданной из оболочки
	__int32 public_get_save_cnt_move();

	//---------------------------------------------------------------------------
	// инициализируем хеш-массив повторов возрастающими числами что бы исключить ложное срабатывание
	void public_ini_hash_three();

	//---------------------------------------------------------------------------
	// инициализируем хеш-массив повторов возрастающими числами что бы исключить ложное срабатывание
	void public_ini_hash_string_moves();

	//---------------------------------------------------------------------------
	// запоминаем хеш-ключ на текущей глубине
	// нужно для детектора повторов в линии варианта
	void public_save_hash_three
	(
		unsigned __int64 key,// хеш-ключ
		unsigned __int8 depth // глубина
	);

	//---------------------------------------------------------------------------
	// запоминаем хеш-ключ для текущего хода
	// нужно для детектора повторов в линии партии переданной оболочкой
	void public_save_hash_string_moves
	(
		unsigned __int64 key,// хеш-ключ
		unsigned __int16 cnt_move // счетчик ходов
	);

	//---------------------------------------------------------------------------
	// анализируем линию ключей полученную из строки партии. если видим совпадение то возвращаем 1 иначе 0
	// конечно совпадение не должно быть трехкратным ведь тогда это уже ничья
	bool public_analysis_hash_string_moves
	(
		unsigned __int8 depth // глубина
	);

}