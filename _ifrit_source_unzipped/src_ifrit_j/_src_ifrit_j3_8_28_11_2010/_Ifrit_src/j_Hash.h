#include "a_Structure.h"
#include "a_List_surplus_moves.h"

#define TEST_H 0 // включаем-выключаем(1-0) режим вывода в файл тестовой информации

#define TEST_WRITE_READ 0 // включаем-выключаем(1-0) режим подсчета количества
                          // записанных и считанных позиций
                          // надо еще включить флаг TEST_WRITE_READ_WN в c_Iterative_Deepening.cpp

//---------------------------------------------------------------------------
/*
 * АВТОР Бренкман Андрей (Brenkman Andrey)
 * ПОСЛЕДНЕЕ ИЗМЕНЕНИЕ  9.03.2009 20.1.2010
*/
//---------------------------------------------------------------------------

/*
 УРОВЕНЬ МОЕГО ДОВЕРИЯ 40%

 реализуем хеш-таблицу
 работаем с хеш-таблицей и памятью под нее
*/

namespace HASHM
{
	// лучше наверное перечислением сделать
	const unsigned __int8 EXACT = 1; // точный ход
	const unsigned __int8 LOWER = 2; // отсечка по бете(альфе)
	const unsigned __int8 UPPER = 3; // альфу(бету) улучшить не удалось


// ТЕСТ ХЕШ - ТАБЛИЦЫ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#if TEST_WRITE_READ

	//---------------------------------------------------------------------------
	// обнуляем счетчики
	void test_hash_ini();

	//---------------------------------------------------------------------------
	// печатаем счетчики
	void test_hash_print();

#endif // TEST_WRITE_READ
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	// РАБОТА С ХЕШ - ТАБЛИЦЕЙ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	//---------------------------------------------------------------------------
	// выделяем память под хеш-таблицу. размер задается в мегабайтах
	void public_hash_size_ini_default
	(
		unsigned __int16 hash_size// размер хеш-таблицы в мегабайтах
	);

	//---------------------------------------------------------------------------
	// освобождаем память из под хеш-таблицы и по новой выделяем память под хеш-таблицу.
	// размер задается в мегабайтах
	void public_hash_size_resize
	(
		unsigned __int16 hash_size// размер хеш-таблицы в мегабайтах
	);

	//---------------------------------------------------------------------------
	// освобождаем память из под хеш-таблицы
	void public_hash_size_free();

	//---------------------------------------------------------------------------
	// инициализируем все ключи в хеш-таблице 0
	void public_ini_hash_moves();

	//---------------------------------------------------------------------------
	// кэшируем лучший на данный момент ход или оценку (зависит от поиска)
	void public_save_best_hash_score_or_move
	(
		unsigned __int8 i,// номер хода по списку
		unsigned __int64 key,// хеш-ключ
		class List_surplus_moves * p_list_surplus_moves,// список ходов
		__int32 score,// оценка хода
		unsigned __int8 flag_hash_score,// флаг хода (1- улучшили альфу(бету); 3-просто локальный максимум(минимум); 2-отсечка по бете(альфе))
		unsigned __int8 depth,// глубина записи хода
		unsigned __int8 depth_max// максимальная глубина расчета
	);

	//---------------------------------------------------------------------------
	// смотрим не встречалась ли нам такая позиция. если встречалась 
	// то применяем сохраненную оценку
	// функцию используем для отсечки по оценке из хеш-таблицы
	__int32 public_look_hash_score_white
	(
		const unsigned __int64 key,// хеш-ключ
		const unsigned __int8 depth,// глубина
		const unsigned __int8 depth_max,// максимальная глубина
		const __int32 alpha,//
		const __int32 beta,//
		unsigned __int8 & test_flag_hash_moves,// флаг хода (1- улучшили альфу(бету); 3-просто локальный максимум(минимум); 2-отсечка по бете(альфе))
		unsigned __int8 & hash_depth,// максимальная глубина
		unsigned __int8 & hash_depth_max// максимальная глубина
	);

	//---------------------------------------------------------------------------
	// смотрим не встречалась ли нам такая позиция если встречалась 
	// то применяем сохраненную оценку
	// функцию используем для отсечки по оценке из хеш-таблицы
	__int32 public_look_hash_score_black
	(
		const unsigned __int64 key,// хеш-ключ
		const unsigned __int8 depth,// глубина
		const unsigned __int8 depth_max,// максимальная глубина
		const __int32 alpha,//
		const __int32 beta,//
		unsigned __int8 & test_flag_hash_moves,// флаг хода (1- улучшили альфу(бету); 3-просто локальный максимум(минимум); 2-отсечка по бете(альфе))
		unsigned __int8 & hash_depth,// максимальная глубина
		unsigned __int8 & hash_depth_max// максимальная глубина
	);

	//---------------------------------------------------------------------------
	// смотрим не встречалась ли нам такая позиция если встречалась то ее ход смотрим первым
	void public_look_hash_move
	(
		class List_surplus_moves * p_list_surplus_moves,// список ходов
		const unsigned __int64 key,// хеш - ключ
		const unsigned __int8 depth,// глубина
		unsigned __int8  & flag_insert_hash_move//флаг того что удалось найти хеш-ход и поднять на первую позицию
	);

	//---------------------------------------------------------------------------
	// обнуляем возраст позиции
	void public_set_age_0();

	//---------------------------------------------------------------------------
	// увеличиваем возраст позиции
	void public_aging();

}

//////////////////////////////////////////////////////////////////////////////////////////
//private:

namespace HASHM{

	// РАБОТА С ХЕШ - ТАБЛИЦЕЙ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	//---------------------------------------------------------------------------
	// кэшируем лучший на данный момент ход 
	inline void save_best_hash_move
	(
		unsigned __int8 i,// номер хода по списку
		unsigned __int32 key_lock_32,//
		class List_surplus_moves * p_list_surplus_moves,// список ходов
		unsigned __int8 delta_depth,// глубина записи хода
		unsigned __int32 ind//
	);

	//---------------------------------------------------------------------------
	// кэшируем ход т.е. записываем ход в хеш-таблицу
	inline void save_hash_move
	(
		unsigned __int8 i,// номер хода по списку
		unsigned __int32 key_lock_32,//
		class List_surplus_moves * p_list_surplus_moves,// список ходов
		unsigned __int8 delta_depth,// глубина записи хода
		unsigned __int32 ind//  
	);

	//---------------------------------------------------------------------------
	// кэшируем лучшую на данный момент оценку
	inline void save_best_hash_score
	(
		unsigned __int32 key_lock_32,//
		__int32 score,// оценка хода
		unsigned __int8 flag_hash_score,// флаг хода (1- улучшили альфу(бету); 3-просто локальный максимум(минимум); 2-отсечка по бете(альфе))
		unsigned __int8 delta_depth,// глубина записи хода
		unsigned __int32 ind//
	);

	//---------------------------------------------------------------------------
	// кэшируем оценку т.е. записываем ее в хеш-таблицу
	inline void save_hash_score
	(
		unsigned __int32 key_lock_32,//
		__int32 score,// оценка хода
		unsigned __int8 flag_hash_score,// флаг хода (1- улучшили альфу(бету); 3-просто локальный максимум(минимум); 2-отсечка по бете(альфе))
		unsigned __int8 delta_depth,// глубина записи хода
		unsigned __int32 ind//  
	);

	//---------------------------------------------------------------------------
	// тестируем хеш-таблицу. печатаем полное количество элементов 
	// сколько использовали а сколько пустых
	void TEST_Hash_index_print();

}
