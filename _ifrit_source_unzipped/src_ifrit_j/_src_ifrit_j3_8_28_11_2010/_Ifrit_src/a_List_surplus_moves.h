#ifndef A_LIST_SURPLUS_MOVES_H
#define A_LIST_SURPLUS_MOVES_H


#include "a_Structure.h"
#include "a_List_surplus_moves_const.h"
#include "a_Chess_bitboard.h"

// a_List_surplus_moves_generator.cpp
#define TEST_B 0   // включаем-выключаем(1-0) режим вывода в файл тестовой информации
#define KONTROL_B 0 // включаем-выключаем(1-0) контроль списка ходов

//---------------------------------------------------------------------------
/*
 * АВТОР Бренкман Андрей (Brenkman Andrey)
 * ПОСЛЕДНЕЕ ИЗМЕНЕНИЕ 20.11.2010
*/
//---------------------------------------------------------------------------

/*
 УРОВЕНЬ МОЕГО ДОВЕРИЯ 90%

Класс List_surplus_moves
включает в себя список избыточных ходов
и методы для работы со списком
такие как:
генерация списка ходов
сортировка списка ходов

*/

//---------------------------------------------------------------------------
// список возможных ходов 
class List_surplus_moves 
{
	// классы из которых возможен прямой доступ к закрытым полям
	friend class Chess_bitboard;

//////////////////////////////////////////////////////////////////////////////////////////
//public:

	__int32 move[MAX_MOVE];
	/*
	в целом числе массива move мы упаковали следующую информацию (используем 27 бит)
	--3 бит--      --6 бит--   --6 бит--     --6 бит--  --6 бит-- 
	ходящая фигура  куда ходим  откуда ходим  тип хода   взятая фигура

	//-------------------------------------------------
	идем справа т.е. с младшего бита
	--6 бит-- 
	взятая фигура

	0 - нет фигуры
	1 - пешка 
	2 - конь 
	3 - слон
	4 - ладья 
	5 - ферзь 
	6 - король

	запись move = тип фигуры
	 чтение move & 63 ( 63 это ...000111111)

	//-------------------------------------------------
	--6 бит--
	тип хода

	0 - нет хода
	1 – простой ход
	2 – взятие
	3 – длинная рокировка
	4 – короткая рокировка
	5 – взятие на проходе

	12 - превращение в конь 
	13 - превращение в слон
	14 - превращение в ладья 
	15 - превращение в ферзь 

	22 - взятие с превращением в конь 
	23 - взятие с превращением в слон
	24 - взятие с превращением в ладья 
	25 - взятие с превращением в ферзь 
 
	запись move = move | (тип хода << 6)
	чтение (move>>6) & 63

	//-------------------------------------------------
	--6 бит--
	откуда ходим (0 -63)
	запись move = move | (откуда ходим << 12)
	чтение (move>>12) & 63

	//-------------------------------------------------
	--6 бит--
	куда ходим (0 -63)
	запись move = move | (куда ходим << 18)
	чтение (move>>18) & 63

	//-------------------------------------------------
	--3 бит-- 
	ходящая фигура
	0 - нет фигуры
	1 - пешка 
	2 - конь 
	3 - слон
	4 - ладья 
	5 - ферзь 
	6 - король
	запись move = move | (куда ходим << 24)
	чтение (move>>24) & 7 ( 7 это ...000111)
	*/

	// оценка используемая для сортировки ходов
	__int32 sorting_score[MAX_MOVE];

	// конец взятий в списке точнее первое не взятие т.е количество взятий 
	// (помним что массив у нас начинается с нуля)
	unsigned __int8 end_captures;

	// конец списка точнее первая пустая позиция т.е. количество ходов
	unsigned __int8 end_list;


//////////////////////////////////////////////////////////////////////////////////////////
public:

	// доступ к полям класса

	// ход
	inline __int32 get_move(const unsigned __int16 n)
	{
		return move[n];
	};

	//  оценка используемая для сортировки ходов
	inline __int32 get_sorting_score(const unsigned __int16 n)
	{
		return sorting_score[n];
	};

	// конец взятий в списке точнее первое не взятие т.е количество взятий 
	inline unsigned __int8 get_end_captures()
	{
		return end_captures;
	};

	// конец списка точнее первая пустая позиция т.е. количество ходов
	inline unsigned __int8 get_end_list()
	{
		return end_list;
	};


//////////////////////////////////////////////////////////////////////////////////////////
public:

	// изменяем поля класса

	//  оценка используемая для сортировки ходов
	inline void set_sorting_score(const unsigned __int16 n,__int32 _sorting_score)
	{
		sorting_score[n] = _sorting_score;
	};





//////////////////////////////////////////////////////////////////////////////////////////
public:
// реализация в файле
// a_List_surplus_moves_generator.cpp

	//---------------------------------------------------------------------------
	// генерируем список взятий + превращения пешки (для белых)
	void public_generator_captures_white
	(
		const class Chess_bitboard * const p_bitboard// представление доски            
	);

	//---------------------------------------------------------------------------
	// генерируем список взятий  + превращения пешки (для черных)
	void public_generator_captures_black
	(
		const class Chess_bitboard * const p_bitboard// представление доски
	);


	//---------------------------------------------------------------------------
	// генерируем список остальных ходов 
	// (т.е. всех ходов кроме взятий + превращения пешки)(для белых)
	void public_generator_move_white
	(
		const class Chess_bitboard * const p_bitboard// представление доски
	);

	//---------------------------------------------------------------------------
	// генерируем список остальных ходов 
	// (т.е. всех ходов кроме взятий + превращения пешки)(для черных)
	void public_generator_move_black
	(
		const class Chess_bitboard * const p_bitboard// представление доски
	);

	// эти две функции в этом а не в другом классе в силу однотипности реализации

	//---------------------------------------------------------------------------
	// под боем ли король белых если шаха нет то функция 
	// возвращает 0 иначе цифру шахующей фигуры
	unsigned __int8 public_king_white_check
	(
		const class Chess_bitboard * const p_bitboard// представление доски
	);

	//---------------------------------------------------------------------------
	// под боем ли король черных если шаха нет то функция 
	// возвращает 0 иначе цифру шахующей фигуры
	unsigned __int8 public_king_black_check
	(
		const class Chess_bitboard * const p_bitboard// представление доски
	);


//---------------------------------------------------------------------------
// это тестовая функция и именно поэтому она в этом, а не в другом классе 
// печатаем битбоард(bit board) доску
#if TEST_B
	void Bitboard_print
	(
		const class Chess_bitboard * const p_bitboard// представление доски
	);
#endif//TEST_B


//////////////////////////////////////////////////////////////////////////////////////////
private:

	// эти две функции в этом а не в другом классе для скорости

	//---------------------------------------------------------------------------
	// под боем ли белые поля если шаха нет то функция 
	// возвращает 0 иначе цифру шахующей фигуры
	inline unsigned __int8 white_check_square
	(
		const unsigned __int8 & sq,//индекс проверяемого поля(0-63) 
		const class Chess_bitboard * const p_bitboard// представление доски
	);

	//---------------------------------------------------------------------------
	// под боем ли черные поля если шаха нет то функция 
	// возвращает 0 иначе цифру шахующей фигуры
	inline unsigned __int8 black_check_square
	(
		const unsigned __int8 & sq,//индекс проверяемого поля(0-63) 
		const class Chess_bitboard * const p_bitboard// представление доски
	);

	//---------------------------------------------------------------------------
	// заполняем список ходов - взятия за белых
	// две функции только из за разного контроля списков(строки взятия)
	inline void list_capture_white
	(
		unsigned __int8 name,// имя ходящей фигуры
		unsigned __int8 type_move,// тип хода
		const unsigned __int8 & from,// откуда ходим
		const unsigned __int8 & to,// куда ходим
		unsigned __int8 & count,// номер хода в списке
		const class Chess_bitboard * const p_bitboard// представление доски
	);

	//---------------------------------------------------------------------------
	// заполняем список ходов - взятия за черных
	// две функции только из за разного контроля списков(строки взятия)
	inline void list_capture_black
	(
		unsigned __int8 name,// имя ходящей фигуры
		unsigned __int8 type_move,// тип хода
		const unsigned __int8 & from,// откуда ходим
		const unsigned __int8 & to,// куда ходим
		unsigned __int8 & count,// номер хода в списке
		const class Chess_bitboard * const p_bitboard// представление доски
	);

	//---------------------------------------------------------------------------
	// заполняем список ходов
	inline void list_record_move
	(
		unsigned __int8 name,// имя ходящей фигуры
		unsigned __int8 type_move,// тип хода
		const unsigned __int8 & from,// откуда ходим
		const unsigned __int8 & to,// куда ходим
		unsigned __int8 & count,// номер хода в списке
		const class Chess_bitboard * const p_bitboard// представление доски
	);

	//---------------------------------------------------------------------------
	// заполняем список ходов для особых случаев типа рокировки 
	// взятия на проходе и превращений пешек
	inline void list_record_special
	(
		unsigned __int8 name,// имя ходящей фигуры
		unsigned __int8 d_m,// тип хода
		unsigned __int8 & p,// номер хода в списке
		const unsigned __int8 & from,// откуда ходим
		unsigned __int8 to,// куда ходим
		unsigned __int8 capture// имя взятой фигуры
	);

	//---------------------------------------------------------------------------
	// контролируем выход за пределы доски, за пределы списка а также пустые взятия  
	// все это для белых фигур генератора взятий
	inline void KONTROL_captures_W
	(
		const class Chess_bitboard * p_bitboard,// представление доски
		const unsigned __int8 * p_from,// откуда ходит фигура
		const unsigned __int8 * p_to,// куда ходит фигура
		const unsigned __int8 * p_p,// номер хода в списке
		unsigned __int8 name_figure// имя ходящей фигуры
	);

	//---------------------------------------------------------------------------
	// контролируем выход за пределы доски, за пределы списка а также пустые взятия  
	// все это для черных фигур генератора взятий
	inline void KONTROL_captures_B
	(
		const class Chess_bitboard * p_bitboard,// представление доски
		const unsigned __int8 * p_from,// откуда ходит фигура
		const unsigned __int8 * p_to,// куда ходит фигура
		const unsigned __int8 * p_p,// номер хода в списке
		unsigned __int8 name_figure// имя ходящей фигуры
	);

	//---------------------------------------------------------------------------
	// контролируем выход за пределы доски, за пределы списка 
	// для генератора ходов 
	inline void KONTROL_move
	(
		const unsigned __int8 * p_from,// откуда ходит фигура
		const unsigned __int8 * p_to,// куда ходит фигура
		const unsigned __int8 * p_p// номер хода в списке
	);

	//---------------------------------------------------------------------------
	// ищем первый установленный бит(т.е. бежим справа)
	__inline __int32 bit_scan_forward_win32
	(
		unsigned __int64 analyzed_number// число в котором ищем взведенный бит
	);

	//---------------------------------------------------------------------------
	// ищем последний установленный бит(т.е. бежим слева)
	__inline __int32 bit_scan_reverse_win32
	(
		unsigned __int64 analyzed_number// число в котором ищем взведенный бит
	);


//////////////////////////////////////////////////////////////////////////////////////////
public:
// реализация в файле
// a_List_surplus_moves_sorting.cpp

	//---------------------------------------------------------------------------
	// полная сортировка
	void sorting_moves();

	//---------------------------------------------------------------------------
	// полная сортировка корневого списка
	void sorting_white_moves_root();

	//---------------------------------------------------------------------------
	// полная сортировка корневого списка
	void sorting_black_moves_root();

//////////////////////////////////////////////////////////////////////////////////////////
public:
// реализация в файле
// j_Killer.cpp

	// тут проблема будет !!!! когда доберусь до переделки киллера в класс
	//---------------------------------------------------------------------------
	// вставляем киллера в начало списка(позиция start) 
	void public_insert_killer
	(
		const unsigned __int8 depth,// текущая глубина
		unsigned __int8 start//позиция с которой ищем и на которую вставляем киллер
	);

//////////////////////////////////////////////////////////////////////////////////////////
public:
// реализация в файле
// j_Hash.cpp

	// тут проблема будет !!!! когда доберусь до переделки хеш-таблицы в класс
	//---------------------------------------------------------------------------
	// поднимаем хеш-ход на первую позицию в списке ходов насчитанных для данной позиции
	inline void insert_hash_moves
	(
		unsigned __int32 ind,// хеш - ключ
		unsigned __int8 depth ,// глубина
		unsigned __int8  & flag_insert_hash_move//флаг того что удалось найти хеш-ход и поднять на первую позицию
	);

};

 #endif //A_LIST_SURPLUS_MOVES_H

/*
логика
             и &  0 0 1 первый операнд
                  0 1 1 второй операнд
                  -----
                  0 0 1 результат

           или |  0 0 1
                  0 1 1
                  -----
                  0 1 1

   исключающее ^  0 0 1
   или            0 1 1
                  -----
                  0 1 0

*/