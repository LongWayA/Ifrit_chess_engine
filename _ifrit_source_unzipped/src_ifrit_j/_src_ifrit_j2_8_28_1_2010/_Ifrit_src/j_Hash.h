#include "a_structure.h"

//-----------------------------------------------------------------------------------
/*
 * реализуем хеш-таблицу
 *
 * АВТОР ChessTerminator75
 * ПОСЛЕДНЕЕ ИЗМЕНЕНИЕ  9.03.2009 20.1.2010
 *
*/
//---------------------------------------------------------------------------

#define TEST_H 0 // включаем-выключаем(1-0) режим вывода в файл тестовой информации

#define TEST_WRITE_READ 0 // включаем-выключаем(1-0) режим подсчета количества
                          // записанных и считанных позиций
                          // надо еще включить флаг TEST_WRITE_READ_WN в c_Iterative_Deepening.cpp

#define U64(u) (u##ui64)

/*******************************************
класс HASHM

работаем с хеш-таблицей и памятью под нее

********************************************/
class HASHM{


// максимальное количество элементов в хеш-таблице
unsigned __int64 max_index_hash;

// указатель на хеш-таблицу(это еще Си стиль)
struct T_hash_moves * p_hash_moves;

// в начале нам нужно заполнить вспомогательный массив случайных чисел 
// связанных с расположением фигуры на доске в нем все фигуры на всех полях
// это трехмерный массив координаты которого цвет, имя, координата фигуры
// массив этот глобальный и содержит случайные числа
// в дальнейшем складывая эти числа мы получим случайный ключ тем не менее
// однозначно связанный с данной позицией
// [цвет фигуры][имя фигуры][координата фигуры]
// 2*6*64= 768 
unsigned __int64 random_piese_key[2][7][64];

// массив для запоминания хеш-ключей позиций при погружении на глубину
// т.е. у нас записываются не только ходы в pv_current но и ключи позиций
// другими словами запоминаем ветку ключей позиций
unsigned __int64 hash_three_moves[120];

// массив для запоминания хеш-ключей позиций
// при анализе входящей строки от оболочки
// другими словами запоминаем ветку ключей позиций расчитанных по входящей строке от оболочки
unsigned __int64 hash_string_moves[1000];

// запоминаем количество ходов в строке
unsigned __int16 save_cnt_move; 

// возраст элемента таблицы. нужен что бы перезаписывать элементы от прошлых позиций
unsigned __int8 age; 


#if TEST_WRITE_READ

 // тестируем запись в хеш таблицу

 // общее количество записанных позиций
 unsigned __int32 hash_write_all;

 // количество записанных позиций для сортировки ходов
 unsigned __int32 hash_move_write;

 // количество записанных позиций для отсечки по оценке (LOWER // отсечка по бете(альфе))
 unsigned __int32 hash_score_write_low;

 // количество записанных позиций для отсечки по оценке (UPPER 3 альфу(бету) улучшить не удалось)
 unsigned __int32 hash_score_write_high;


// тестируем использование кеша

 // используем для сортировки ходов
 unsigned __int32 hash_read_sorting; 

 // используем для отсечки по оценке. общее количество
 unsigned __int32 hash_read_score; 

 // используем для отсечки по оценке. LOWER
 unsigned __int32 hash_read_score_LOWER; 

 // используем для отсечки по оценке. UPPER 
 unsigned __int32 hash_read_score_UPPER; 


#endif // TEST_WRITE_READ


//TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
#if TEST_H
 int hash_save;
#endif 
//TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT

//////////////////////////////////////////////////////////////////////////////////////////
public:

// ТЕСТ ХЕШ - ТАБЛИЦЫ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#if TEST_WRITE_READ

//---------------------------------------------------------------------------
// обнуляем счетчики
void Test_hash_ini();

//---------------------------------------------------------------------------
// печатаем счетчики
void Test_hash_print();

#endif // TEST_WRITE_READ
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




// РАБОТА С ХЕШ - ТАБЛИЦЕЙ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//---------------------------------------------------------------------------
// смотрим не встречалась ли нам такая позиция если встречалась то применяем сохраненную оценку
// функцию используем для отсечки по оценке
__int32 Look_hash_score_white(const unsigned __int64 key,// хеш-ключ
			                  const unsigned __int8 depth,// глубина
                              const unsigned __int8 depth_max,// максимальная глубина
					          const __int32 alpha,//
		                      const __int32 beta,//
                              unsigned __int8 & test_flag_hash_moves,// флаг хода (1- улучшили альфу(бету); 3-просто локальный максимум(минимум); 2-отсечка по бете(альфе))
                              unsigned __int8 & hash_depth,// максимальная глубина
                              unsigned __int8 & hash_depth_max// максимальная глубина
			                  );

//---------------------------------------------------------------------------
// смотрим не встречалась ли нам такая позиция если встречалась то применяем сохраненную оценку
// функцию используем для отсечки по оценке
__int32 Look_hash_score_black(const unsigned __int64 key,// хеш-ключ
			                  const unsigned __int8 depth,// глубина
                              const unsigned __int8 depth_max,// максимальная глубина
					          const __int32 alpha,//
		                      const __int32 beta,//
                              unsigned __int8 & test_flag_hash_moves,// флаг хода (1- улучшили альфу(бету); 3-просто локальный максимум(минимум); 2-отсечка по бете(альфе))
                              unsigned __int8 & hash_depth,// максимальная глубина
                              unsigned __int8 & hash_depth_max// максимальная глубина
			                  );

//---------------------------------------------------------------------------
// смотрим не встречалась ли нам такая позиция если встречалась то ее ход смотрим первым
void Look_hash_move(struct T_list_surplus_moves * p_list_surplus_moves,// список ходов
			        const unsigned __int64 key,// хеш - ключ
			        const unsigned __int8 depth,// глубина
			        unsigned __int8  & flag_insert_hash_move//флаг того что удалось найти хеш-ход и поднять на первую позицию
			        );

//---------------------------------------------------------------------------
// кэшируем лучший на данный момент ход или оценку (зависит от поиска)
void Save_best_hash(unsigned __int8 i,// номер хода по списку
				    unsigned __int64 key,// хеш-ключ
				    struct T_list_surplus_moves * p_list_surplus_moves,// список ходов
				    __int32 score,// оценка хода
					unsigned __int8 flag_hash_score,// флаг хода (1- улучшили альфу(бету); 3-просто локальный максимум(минимум); 2-отсечка по бете(альфе))
					unsigned __int8 depth,// глубина записи хода
					unsigned __int8 depth_max// максимальная глубина расчета
					);

//---------------------------------------------------------------------------
// освобождаем память из под хеш-таблицы
void Hash_size_free();

//---------------------------------------------------------------------------
// выделяем память под хеш-таблицу. размер задается в мегабайтах
void Hash_size_ini_default(unsigned __int16 hash_size// размер хеш-таблицы в мегабайтах
						   );

//---------------------------------------------------------------------------
// инициализируем все ключи в хеш-таблице 0
void Ini_hash_moves();

//---------------------------------------------------------------------------
// освобождаем память из под хеш-таблицы и по новой выделяем память под хеш-таблицу. размер задается в мегабайтах
void Hash_size_resize(unsigned __int16 hash_size// размер хеш-таблицы в мегабайтах
				      );

//---------------------------------------------------------------------------
// тестируем хеш-таблицу. печатаем полное количество элементов сколько использовали а сколько пустых
void TEST_Hash_index_print();

//---------------------------------------------------------------------------
// обнуляем возраст позиции
void Set_age_0();

//---------------------------------------------------------------------------
// следующий век :)
// увеличиваем возраст позиции
void Aging();



// РАБОТА С ХЕШ - КЛЮЧОМ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//---------------------------------------------------------------------------
// меняем ключ во время хода
void Modification_random_key(bool  colour_figure,// цвет ходящей стороны
							 unsigned __int8 i,// номер хода по списку
							 struct T_list_surplus_moves * p_list_surplus_moves,// список ходов
							 struct T_Bitboard * p_bitboard,// представление доски
                             struct T_undo undo[]//информация для отката хода
							 );

//---------------------------------------------------------------------------
// инициализируем ключ начальной позиции
void Start_position_random_key(struct T_Bitboard * p_bitboard// представление доски
							   );

//---------------------------------------------------------------------------
// каждой возможной позиции каждой возможной фигуры 
// присваиваем случайное число
void Ini_random_piese_key();



// ПОВТОРЫ ПОЗИЦИЙ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//---------------------------------------------------------------------------
// возвращаем количество ходов в строке игры переданной из оболочки
__int32 get_save_cnt_move();

//---------------------------------------------------------------------------
// запоминаем хеш-ключ на текущей глубине
// нужно для детектора повторов в линии варианта
void Save_hash_three(unsigned __int64 key,// хеш-ключ
					 unsigned __int8 depth // глубина
					 );

//---------------------------------------------------------------------------
// запоминаем хеш-ключ для текущего хода
// нужно для детектора повторов в линии партии переданной оболочкой
void Save_hash_string_moves(unsigned __int64 key,// хеш-ключ
					        unsigned __int16 cnt_move // счетчик ходов
					        );

//---------------------------------------------------------------------------
// анализируем линию ключей полученную из строки партии. если видим совпадение то возвращаем 1 иначе 0
// конечно совпадение не должно быть трехкратным ведь тогда это уже ничья
bool Analysis_hash_string_moves(unsigned __int8 depth // глубина
						        );

//---------------------------------------------------------------------------
// инициализируем хеш-массив повторов возрастающими числами что бы исключить ложное срабатывание
void HASHM::Ini_hash_three();

//---------------------------------------------------------------------------
// инициализируем хеш-массив повторов возрастающими числами что бы исключить ложное срабатывание
void HASHM::Ini_hash_string_moves();


//////////////////////////////////////////////////////////////////////////////////////////
private:

// РАБОТА С ХЕШ - ТАБЛИЦЕЙ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//---------------------------------------------------------------------------
// кэшируем лучший на данный момент ход 
void Save_best_hash_move(unsigned __int8 i,// номер хода по списку
						 unsigned __int32 key_lock_32,//
						 struct T_list_surplus_moves * p_list_surplus_moves,// список ходов
						 unsigned __int8 delta_depth,// глубина записи хода
                         unsigned __int32 ind//
						 );

//---------------------------------------------------------------------------
// кэшируем ход т.е. записываем ход в хеш-таблицу
void Save_hash_move(unsigned __int8 i,// номер хода по списку
				    unsigned __int32 key_lock_32,//
					struct T_list_surplus_moves * p_list_surplus_moves,// список ходов
				    unsigned __int8 delta_depth,// глубина записи хода
                    unsigned __int32 ind//  
				    );

//---------------------------------------------------------------------------
// кэшируем лучшую на данный момент оценку
void Save_best_hash_score(unsigned __int32 key_lock_32,//
						  __int32 score,// оценка хода
						  unsigned __int8 flag_hash_score,// флаг хода (1- улучшили альфу(бету); 3-просто локальный максимум(минимум); 2-отсечка по бете(альфе))
						  unsigned __int8 delta_depth,// глубина записи хода
                          unsigned __int32 ind//
						  );

//---------------------------------------------------------------------------
// кэшируем оценку т.е. записываем ее в хеш-таблицу
void Save_hash_score(unsigned __int32 key_lock_32,//
					 __int32 score,// оценка хода
				     unsigned __int8 flag_hash_score,// флаг хода (1- улучшили альфу(бету); 3-просто локальный максимум(минимум); 2-отсечка по бете(альфе))
				     unsigned __int8 delta_depth,// глубина записи хода
                     unsigned __int32 ind//  
				     );


//---------------------------------------------------------------------------
// поднимаем хеш-ход на первую позицию в списке ходов насчитанных для данной позиции
void Insert_hash_moves(struct T_list_surplus_moves * p_list_surplus_moves,// список ходов
					   unsigned __int32 ind,// хеш - ключ
					   unsigned __int8 depth ,// глубина
					   unsigned __int8  & flag_insert_hash_move//флаг того что удалось найти хеш-ход и поднять на первую позицию
					   );

//---------------------------------------------------------------------------

// РАБОТА С ХЕШ - КЛЮЧОМ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//---------------------------------------------------------------------------
// генерируем случайный 64 битный ключ
unsigned __int64 rand_64();


// ПОВТОРЫ ПОЗИЦИЙ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// устарела
void Print_hash_moves();

};//class HASHM



