
// АВТОР Бренкман Андрей (Brenkman Andrey)
// ПОСЛЕДНЕЕ ИЗМЕНЕНИЕ 5.12.2008 19.11.2009

#define TEST_F 0; // включаем-выключаем(1-0) режим вывода в файл тестовой информации

#define DELTA_PRUNING 1 // включаем-выключаем(1-0) режим
// нужно основательно тестировать

//!
//--------------------------------------
// отключил предупреждения которые выдаются из за использования условия 
// для препроцессора #if #endif
// unexpected tokens following preprocessor directive - expected a newline
#pragma warning(disable : 4067) 

/*
 УРОВЕНЬ МОЕГО ДОВЕРИЯ 80%

включает в себя данные и методы форсированного перебора:
смотрим только взятия 
используем delta pruning

форсированный перебор позиций 

 Опишу алгоритм расчета взятий для белых. Ясно что для черных аналогично.

 Главное отличие данного алгоритма от обычной альфа-бета оптимизации это использование
 статической оценки для завышения альфы и отсечения по бете. Надо еще заметить что 
 генерируем мы только взятия.

 Что бы понять данный алгоритм нужно вспомнить что такое альфа-бета оптимизация
 и какие особенности добавляет работа со статической оценкой.

 Белые ищут максимум среди минимумов которые нашли черные. Самая большая оценка которую
 белые уже нашли в предыдущем поиске и есть альфа. Таким образом белые стремятся увеличить 
 альфу. Черные ищут минимум. И самая маленькая оценка которую они уже нашли и есть бета.
 Белых интересуют оценки которые больше альфы а все остальные они отбрасывают. Допустим 
 белые сходили и теперь ход черных и найденная оценка меньше альфы. Ясно что поскольку 
 черные ищут минимум в дальнейшем оценка будет только уменьшаться. Но искать дальше 
 бесполезно так как уже ясно что белые эту оценку отбросят.
   
 В форсированном поиске мы считаем только взятия так что программа не видит что брать
 не обязательно а можно просто уклониться. Для того что бы программа не делала 
 проигрывающих взятий мы увеличиваем альфу статической оценкой. В итоге если программа
 найдет лучший вариант то она выберет его а если нет то откажется от дальнейших взятий.

 Когда мы отсекаемся статической оценкой по бете мы исходим из предположения что если 
 позиция уже в нашу пользу а тут еще есть наше взятие то мы либо улучшим оценку либо 
 удержим ее. Так как мы смотрим только взятия и не видим шахов такое предположение не
 уменьшает точность форсированного варианта.

1) Находим статическую оценку позиции.

  1.1 Если статическая оценка больше альфы то присваиваем ее альфе. Проще говоря 
   завышаем альфу статической оценкой.

  1.2 Если альфу завысили то пытаемся сразу отсечь по бете. 

  1.3 Фрагмент кода по пункту 1:

	if (value_stat > alpha)
	{ 
		if (value_stat >= beta)
		{
			return value_stat;
		}

		alpha = value_stat;
		save_best = 1;
	}

---------------------------------------
2) Насчитываем и сортируем по mvv/lva список возможных взятий. Сортировка имеет
   принципиальное значение для ускорения поиска.

  2.1  Дальше обычная альфа-бета. 

  2.2 Фрагмент кода по пункту 2:
	value_max_din = value_stat;

	if (value_din > value_max_din)
	{
		value_max_din = value_din;

		if (value_din > alpha)
		{
			if (value_din >= beta)
			{
				return value_din;
			}

			alpha = value_din;

			//здесь мы перезаписываем лучший вариант соответствующий лучшей оценке
			PVSAVE::public_update_PV_best_point(&pv_best_point);

			save_best = 1;
		}
	}

  Принципиальный момент заключается в том что 
  мы пишем только те цепочки взятий или статическую оценку которые улучшают альфу
	if (save_best == 1)
	{
		if (value_max_din == value_stat)
		{
			// статическую оценку улучшить не удалось

			// здесь мы обновили лучший выходной вариант особенностью является то что мы 
			// в лучший вариант сразу записали оценку
			PVSAVE::public_update_PV_best_max_depth(value_stat,depth); 
		}
		else
		{
			// теперь мы местный лучший вариант скопируем в структуру PV_best что бы передать на более высокий уровень
			PVSAVE::public_update_PV_best(&pv_best_point);
		}
	}
---------------------------------------

*/

class Search_quiescence
{

//////////////////////////////////////////////////////////////////////////////////////
public:

	//---------------------------------------------------------------------------
	// просчитываем только взятия для белых
	__int32 forced_variant_white
	(
		__int32 alpha,//
		const __int32 beta,//
		const unsigned __int8 depth,// глубина
		const bool flag_pv_f// основной ли это вариант (pv)
	);

	//---------------------------------------------------------------------------
	// просчитываем только взятия для черных
	__int32 forced_variant_black
	(
		const __int32 alpha,//
		__int32 beta,//
		const unsigned __int8 depth,// глубина
		const bool flag_pv_f// основной ли это вариант (pv)
	);

	//---------------------------------------------------------------------------
	//TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
	// печатаем список
	// глубина перебора, список
#if TEST_F

	void list_Print_F
	(
		int depth,// текущая глубина
		const class List_surplus_moves & list_surplus_moves//список ходов
	);
#endif

};
