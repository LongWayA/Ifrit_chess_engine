
// АВТОР Бренкман Андрей (Brenkman Andrey)
// ПОСЛЕДНЕЕ ИЗМЕНЕНИЕ 27.02.2009

#include <iostream>

#include "pv_save.h"


/*

 Работа с линией главного варианта

 В целом логика такая.
 У нас есть две глобальные линии варианта - одна заполняется при погружении на глубину, 
 а другая при подъеме с  глубины. Кроме того в каждом узле есть линия лучшего варианта 
 для узла.
 Мы записываем ходы, которые делаем, погружаясь на глубину в линию текущего варианта. 
 На глубине мы перезаписываем их в линию лучшего варианта. Поднимаясь мы в каждом узле 
 запоминаем лучший для данного узла вариант. Уходя из узла, мы лучший в узле вариант 
 перезаписываем в линию лучшего варианта.

 конретнее:

 У нас есть линия варианта общая для всего поиска pv_current. 
 Ее мы заполняем, когда спускаемся на глубину public_update_PV_current.  

 Есть еще лучшая линия варианта pv_best. 
 Ее мы заполняем перед тем как выйти из узла public_update_PV_best.
 Особый случай ее обновления на максимальной глубине public_update_PV_best_max_depth.

 Так же в каждом узле есть лучшая линия варианта для данного узла PV_best_point.
 Ее мы обновляем каждый раз когда в узле нашли лучший ход public_update_PV_best_point.

*/

	struct PV_line pv_current;/// текущий вариант общий для всего поиска(заполняем при погружении на глубину)
	struct PV_line pv_best;/// лучший вариант общий для всего поиска(заполняем при всплытии)


//	===================================================================
// возвращаем лучший вариант
struct PV_line & PV_save::get_pv_best()
{
	return  pv_best;
}

//	===================================================================
// возвращаем текущий вариант
struct PV_line & PV_save::get_pv_current()
{
	return pv_current;
}

//	===================================================================
// обновляем линию лучшего варианта в узле
void PV_save::update_PV_best_point
(
	struct PV_line & PV_best_point// лучший вариант найденный в узле
)
{
	// лучший вариант который функция перебора выдает наверх содержится в структуре PV_best
	// мы не только присваиваем оценку но и вариант соответствующий ей
	// присвоение идет структуре уникальной для каждого узла PV_best_point
	// здесь мы перезаписываем лучший вариант соответствующий лучшей оценке
	for (unsigned __int8 n = 0; n < pv_best.depth_max; n++)
	{
		PV_best_point.move[n] = pv_best.move[n];
	}

	PV_best_point.score_move = pv_best.score_move;
	PV_best_point.depth_max = pv_best.depth_max;
}

//	===================================================================
// обновляем линию лучшего варианта
void PV_save::update_PV_best
(
	const struct PV_line & PV_best_point// лучший вариант найденный в узле
)
{
	// мы пробежали весь список и теперь в структуре PV_best_point содержится лучшая линия
	// теперь мы ее скопируем в структуру PV_best что бы передать на более высокий уровень
	for (unsigned __int8 n = 0; n < PV_best_point.depth_max; n++)
	{
		pv_best.move[n] = PV_best_point.move[n];
	}

	pv_best.score_move = PV_best_point.score_move; 
	pv_best.depth_max = PV_best_point.depth_max;
}

//	===================================================================
// обновляем линию лучшего варианта на максимальной глубине
void PV_save::update_PV_best_max_depth
(
	const __int32 & score,// оценка позиции в конце варианта
	const unsigned __int8 & depth// текущая глубина
)
{
	// мы достигли предельной глубины и статически оценили получившуюся позицию
	// погружаясь на глубину мы на каждом полу ходе заносили ходы варианта в структуру PV_current
	// теперь мы перепишем его в структуру PV_best и прицепим оценку позиции
	// у нас получился вариант приводящий к данной позиции и плюс оценка этой позиции
	// ну и еще конечно длина варианта
	// внимание тут цикл идет от 0 до Depth - 1
	// именно так ведь у нас начальная глубина 0
	for (unsigned __int8 n = 0; n < depth; n++)
	{
		pv_best.move[n] = pv_current.move[n];
	}

	pv_best.score_move = score;

	// запоминаем глубину варианта
	pv_best.depth_max = depth;
}

//	===================================================================
// записываем ход в текущий вариант
void PV_save::update_PV_current
(
	const unsigned __int8 & i,// номер хода в списке ходов
	const unsigned __int8 & depth,// текущая глубина
	const struct List & list_surplus_moves//список возможных ходов
)
{

	// из списка возможных ходов копируем текущий ход в текущий вариант на текущей глубине.
	// мы видим что текущий вариант прописывается до рекурсивного вызова функции Alpha_beta т.е. 
	// мы разматываем нить погружаясь в глубину 
	// запись в структуре PV_current верна сверху и до текущей глубины 
	// то что расположено ниже данного уровня не правильно так как относится к предыдущему узлу.
	pv_current.move[depth] = list_surplus_moves.move[i];
}




