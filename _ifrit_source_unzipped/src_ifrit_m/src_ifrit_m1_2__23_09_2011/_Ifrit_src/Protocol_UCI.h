
/// АВТОР Бренкман Андрей (Brenkman Andrey)
/// ПОСЛЕДНЕЕ ИЗМЕНЕНИЕ 12.06.2007  11.11.2009 19.12.2010 1.1.2011
/// УРОВЕНЬ МОЕГО ДОВЕРИЯ 70%

#include "Position.h"

/// включаем-выключаем(1-0)  режим вывода в 
/// файл(_TEST_FEN.txt) тестовой информации
#define TEST_P 0
				 
/// имя и дата выпуска версии
#define NAME_OF_PROGRAM_AND_DATA_OF_RELEASE "id name Ifrit_m1_2_Beta_23_9_2011"



/// Парсер уки команд.

/// Обрабатываем следующие команды от шахматной графической оболочки.

/// >1:uci
/// Оболочка сообщает нам, что работаем оп уки протоколу.
/// В ответ мы пишем имя движка и автора и подтверждаем 
/// готовность работать по этому протоколу.
/// пишем uciok

/// >1:ucinewgame
/// Новая игра
/// Сбрасываем кэш и возраст в ноль.


/// >1:setoption name Hash value 2 (если размер таблицы задали в 2 мб)
/// считываем установленный размер хеш-таблицы в Mb
/// и на основании этого выделяем память под хеш-таблицу

/*
	> setoption name Ponder value true
	> setoption name Hash value 16
	> setoption name NalimovCache value 4
	> setoption name NalimovPath value D:\tbs
	> setoption name Position Learning value true
	> setoption name BookFile value dbbook.bin
	> setoption name Book Size value Big
	> setoption name Selectivity value 5
	пока не обрабатываю
*/

/// >1:isready
/// К игре готов?
/// Отвечаем что да! (readyok)

/// команды передающие шахматную позицию
/// >1:position startpos (для стартовой позиции)
/// >1:position startpos moves e2e4 e7e5 g1f3 g8f6 f3e5 (для текущей партии)
/// >1:position fen rnb1kb1r/ppppqppp/5n2/8/8/3P1N2/PPP1QPPP/RNB1KB1R w KQkq - 0 1
/// "position startpos" просто начальная позиция
/// "position startpos moves b1c3 b8c6 g1f3 g8f6" начальная позиция 
/// + ходы ведущие к текущей 
/// "position fen 1k1r4/8/8/8/8/8/8/3R2K1 w - - 0 1" задание позиции 
/// через фен представление
/// "position fen 1k1r4/8/8/8/8/8/8/3R2K1 w - - 0 1 moves b1c3 b8c6 g1f3 g8f6" 
/// задание позиции через фен представление + ходы ведущие к текущей 
/// в результате работы класса мы получаем внутреннюю позицию соответствующую позиции
/// закодированной в фен - представлении

/// комнады на обсчет позиции
/// >1:go depth 5 (для счета на заданную глубину - в данном случае 5 полуходов )
/// >1:go wtime 300000 btime 300000 (блиц 5 мин - первый ход)
/// >1:go movetime 5000 ( 5 секунд на ход)
/// >1:go infinite (анализ позиции)

	/// точнее
	/// этот класс вызвает объект класса namespace Go 
	/// и в нем разбираем команду go и запускаем расчет

	/// команды для блица типа 5 мин либо 5 мин + добавление за ход в секундах
	/// > go btime 300000 wtime 300000 
	/// for game in 5min. 

	/// > go btime 302000 wtime 302000 winc 2000 binc 2000 
	/// with incremental clock 5 min + 2 sec. 

	/// время на определенное количество ходов
	/// > go movestogo 40 wtime 300000 btime 300000 
	/// for 40 moves in 5 min. 
	/// причем арена выдает в виде
	/// > go wtime 300000 btime 300000  movestogo 40

	/// это понятно что для анализа
	/// > go infinite 
	/// for analysing. 

	/// время на ход говорят что фриц не поддерживает а 
	///по моему все он держит надо проверять
	/// > go movetime 300000 
	/// Exactly 5min for the next move, not supported by Fritz. 

	/// поиск на заданную глубину
	/// > go depth 5 

/// >1:quit
/// команда на выход
/// особождаем память и закрываем программу

/// >1:stop
/// команда на остановку. обрабатываю в глубине поиска 

namespace Protocol_UCI
{

//////////////////////////////////////////////////////////////////////////////////////
//public:

	/// разбирает входящие UCI команды от графической шахматной оболочки
	void parse_protocol_UCI
	(
		struct Position & position,// представление доски
		const std::string string_in//входящая строка
	);


//////////////////////////////////////////////////////////////////////////////////////
//private:

	///--------------------------------------------------------------------------
	/// считывает в строке и выдает размер хеша в мегабайтах
	unsigned __int16 read_hash_size_Mb
	(
		const std::string string_in //входящая строка
	);

	///---------------------------------------------------------------------------
	/// разбирает входящую фен - позицию
	void parse_position_FEN
	(
		struct Position & position,// представление доски
		const std::string string_in//входящая строка
	);

	///---------------------------------------------------------------------------
	/// загоняем в движок ходы приводящие к текущей позиции из начальной
	void move_to_board
	(
		struct Position & position,// представление доски
		const __int8 move_string[]// строка содержащая ходы
	);

};


