
// АВТОР Бренкман Андрей (Brenkman Andrey)
// ПОСЛЕДНЕЕ ИЗМЕНЕНИЕ 20.11.2010

#include <fstream>
#include <iostream>

#include "Sorting_moves.h"

//	===================================================================
// сортируем взятия
void Sorting_moves::sorting_moves_captures
(
	struct List & list// представление списка ходов
)
{
	__int32 move_s;// используем для запоминания хода
	__int32 score_s;// используем для запоминания оценки хода
	//unsigned __int8 end_captures = end_captures;//количество взятий
	//unsigned __int8 end_list = end_list;//количество ходов

	/*
	список у нас начинается с 0 и имеет вид
	0 взятие
	1 взятие
	2 взятие
	3 ход          end_captures
	т.е. количество взятий на 1 превышает реальный индекс последнего взятия
	4 ход
	5 ход
	6 ход
	7              end_list
	получается что у нас настоящее количество взятий и ходов т.е. если считать с 1

	счетчик взятий и ходов в списке генератор взятий изначально ставит в ноль

	*/

	// 1 сортируем взятия----------------------------------
	/*
	если у нас есть взятия тогда мы их сортируем по оценке обсчитанной еще в генераторе взятий
	идем по списку и сравниваем(меньше ли она) текущую строку со всеми нижестоящими
	понятно что если у нас текущая строка k то следующая строка будет k + 1
	если такая(т.е. больше текущей) строка нашлась то мы меняем местами ее и текущую строку
	таким образом когда мы доходим до конца все взятия у нас отсортированы по убывающей.
	*/
	for (unsigned __int8 k = 0; k < list.end_captures; k++)
	{	
		for (unsigned __int8 i = k + 1; i < list.end_captures; i++)
		{
			if (list.sorting_score[k] < list.sorting_score[i])
			{ 
				//сохраняем данные   
				move_s = list.move[k];
				score_s = list.sorting_score[k];

				//копируем из i в k
				list.move[k] = list.move[i];
				list.sorting_score[k] = list.sorting_score[i];

				//восстанавливаем запись
				list.move[i] = move_s;
				list.sorting_score[i] = score_s;
			}
		}
	}

}

//	===================================================================
// полная сортировка корневого списка
void Sorting_moves::sorting_moves_history
(
	struct List & list// представление списка ходов
)
{
	__int32 move_s;// используем для запоминания хода
	__int32 score_s;// используем для запоминания оценки хода
	//unsigned __int8 end_captures = end_captures;//количество взятий
	//unsigned __int8 end_list = end_list;//количество ходов


	/*
	список у нас начинается с 0 и имеет вид
	0 взятие
	1 взятие
	2 взятие
	3 ход          end_captures
	т.е. количество взятий на 1 превышает реальный индекс последнего взятия
	4 ход
	5 ход
	6 ход
	7              end_list
	получается что у нас настоящее количество взятий и ходов т.е. если считать с 1

	счетчик взятий и ходов в списке генератор взятий изначально ставит в ноль
	*/

	// 1 сортируем корневые ходы----------------------------------
	/*
	мы их сортируем по оценке обсчитанной на предыдущей итерации
	идем по списку и сравниваем(меньше ли она) текущую строку со всеми нижестоящими
	понятно что если у нас текущая строка k то следующая строка будет k + 1
	если такая(т.е. больше текущей) строка нашлась то мы меняем местами ее и текущую строку
	таким образом когда мы доходим до конца все ходы у нас отсортированы по убывающей.
	*/
	for (unsigned __int8 k = list.end_captures; k < list.end_list; k++)
	{	
		for (unsigned __int8 i = k + 1; i < list.end_list; i++)
		{
			if (list.sorting_score[k] < list.sorting_score[i])
			{ 
				// сохраняем данные   
				move_s = list.move[k];
				score_s = list.sorting_score[k];

				// копируем из i в k
				list.move[k] = list.move[i];
				list.sorting_score[k] = list.sorting_score[i];

				// восстанавливаем запись
				list.move[i] = move_s;
				list.sorting_score[i] = score_s;
			}
		}
	}

}


//	===================================================================
// полная сортировка корневого списка
void Sorting_moves::sorting_white_moves_root
(
	struct List & list// представление списка ходов
)
{
	__int32 move_s;// используем для запоминания хода
	__int32 score_s;// используем для запоминания оценки хода
	//unsigned __int8 end_captures = end_captures;//количество взятий
	//unsigned __int8 end_list = end_list;//количество ходов


	/*
	список у нас начинается с 0 и имеет вид
	0 взятие
	1 взятие
	2 взятие
	3 ход          end_captures
	т.е. количество взятий на 1 превышает реальный индекс последнего взятия
	4 ход
	5 ход
	6 ход
	7              end_list
	получается что у нас настоящее количество взятий и ходов т.е. если считать с 1

	счетчик взятий и ходов в списке генератор взятий изначально ставит в ноль
	*/

	// 1 сортируем корневые ходы----------------------------------
	/*
	мы их сортируем по оценке обсчитанной на предыдущей итерации
	идем по списку и сравниваем(меньше ли она) текущую строку со всеми нижестоящими
	понятно что если у нас текущая строка k то следующая строка будет k + 1
	если такая(т.е. больше текущей) строка нашлась то мы меняем местами ее и текущую строку
	таким образом когда мы доходим до конца все ходы у нас отсортированы по убывающей.
	*/
	for (unsigned __int8 k = 0; k < list.end_list; k++)
	{	
		for (unsigned __int8 i = k + 1; i < list.end_list; i++)
		{
			if (list.sorting_score[k] < list.sorting_score[i])
			{ 
				// сохраняем данные   
				move_s = list.move[k];
				score_s = list.sorting_score[k];

				// копируем из i в k
				list.move[k] = list.move[i];
				list.sorting_score[k] = list.sorting_score[i];

				// восстанавливаем запись
				list.move[i] = move_s;
				list.sorting_score[i] = score_s;
			}
		}
	}

}

//	===================================================================
// полная сортировка корневого списка
void Sorting_moves::sorting_black_moves_root
(
	struct List & list// представление списка ходов
)
{
	__int32 move_s;// используем для запоминания хода
	__int32 score_s;// используем для запоминания оценки хода
	//unsigned __int8 end_captures = end_captures;//количество взятий
	//unsigned __int8 end_list = end_list;//количество ходов


	/*
	список у нас начинается с 0 и имеет вид
	0 взятие
	1 взятие
	2 взятие
	3 ход          end_captures
	т.е. количество взятий на 1 превышает реальный индекс последнего взятия
	4 ход
	5 ход
	6 ход
	7              end_list
	получается что у нас настоящее количество взятий и ходов т.е. если считать с 1

	счетчик взятий и ходов в списке генератор взятий изначально ставит в ноль
	*/

	// 1 сортируем корневые ходы----------------------------------
	/*
	мы их сортируем по оценке обсчитанной на предыдущей итерации
	идем по списку и сравниваем(меньше ли она) текущую строку со всеми нижестоящими
	понятно что если у нас текущая строка k то следующая строка будет k + 1
	если такая(т.е. больше текущей) строка нашлась то мы меняем местами ее и текущую строку
	таким образом когда мы доходим до конца все ходы у нас отсортированы по убывающей.
	*/
	for (unsigned __int8 k = 0; k < list.end_list; k++)
	{	
		for (unsigned __int8 i = k + 1; i < list.end_list; i++)
		{
			if (list.sorting_score[k] > list.sorting_score[i])
			{ 
				// сохраняем данные   
				move_s = list.move[k];
				score_s = list.sorting_score[k];

				// копируем из i в k
				list.move[k] = list.move[i];
				list.sorting_score[k] = list.sorting_score[i];

				// восстанавливаем запись
				list.move[i] = move_s;
				list.sorting_score[i] = score_s;
			}
		}
	}
}