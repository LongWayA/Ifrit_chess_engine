#ifndef K_STRUCTURE_H
#define K_STRUCTURE_H


//--------------------------------------------------------------------------
/* +
 * описываем структуры
 *
 * АВТОР ChessTerminator75
 * ПОСЛЕДНЕЕ ИЗМЕНЕНИЕ 27.11.2007
*/
//--------------------------------------------------------------------------

// Bitboard

// максимум на имя фигур
const int NAME = 7;
// максимум на количество фигур одного типа и цвета
const int COORDINATE = 64;
// битовая доска
struct T_Bitboard {
//-------------------------------------------------
// доска представленна следующим образом
//A8(56) B8(57) C8(58) D8(59) E8(60) F8(61) G8(62) H8(63)
//A7(48) B7(49) C7(50) D7(51) E7(52) F7(53) G7(54) H7(55)
//A6(40) B6(41) C6(42) D6(43) E6(44) F6(45) G6(46) H6(47)
//A5(32) B5(33) C5(34) D5(35) E5(36) F5(37) G5(38) H5(39)
//A4(24) B4(25) C4(26) D4(27) E4(28) F4(29) G4(30) H4(31)
//A3(16) B3(17) C3(18) D3(19) E3(20) F3(21) G3(22) H3(23)
//A2(8)  B2(9)  C2(10) D2(11) E2(12) F2(13) G2(14) H2(15)
//A1(0)  B1(1)  C1(2)  D1(3)  E1(4)  F1(5)  G1(6)  H1(7)
//
//A1(MSB)- это нулевой бит H8(LSB)-это 63 бит
// т.е. битовая развертка выглядит следующим образом
// H8(63) G8(62) F8(61) . . . . . .C1(2) B1(1) A1(0)
//-------------------------------------------------
// ДОСКА
// в этих 64 битных переменных мы храним все белые фигуры и все черные фигуры
// конечно тут пишется только факт наличия или отсутвия фигуры в каком то поле
// причем неизвестно  что это за фигура известен только цвет по принадлежности
// к той или иной переменной
unsigned __int64  all_piece;
unsigned __int64  all_white_piece;
unsigned __int64  all_black_piece;

//-------------------------------------------------
// СПИСКИ ФИГУР
/*
 имя фигуры
 0 - нет фигуры
 1 - пешка 
 2 - конь 
 3 - слон
 4 - ладья 
 5 - ферзь 
 6 - король
*/
// битовые списки черных и белых фигур
unsigned __int64 white_piece[NAME];
unsigned __int64 black_piece[NAME];

// имя фигуры от координаты 
int white_name_from_coord[COORDINATE];
int black_name_from_coord[COORDINATE];

//-------------------------------------------------
// ВСПОМОГАТЕЛЬНАЯ ИНФОРМАЦИЯ
// цвет хода 0 - черные 1 - белые
int  colour_move;

// разрешение бития на проходе 1/0
int  taking_passage_yes;
// х координата битого поля(конвертируем из буквы) 
int  taking_passage_x;
// у координата битого поля(у нас инверсна относительно нормальной доски) 
int  taking_passage_y;

// рокировка белых в длинную сторону   1/0
int  castling_Q;
// рокировка белых в короткую сторону  1/0
int  castling_K;
// рокировка черных в длинную сторону  1/0
int  castling_q;
// рокировка черных в короткую сторону 1/0
int  castling_k;

// хеш ключ позиции(нужно? уходить от int )
int hash_key ;
// оценка позиции
int eval ;
};//struct T_Bitboard {






///////////////////////////////////////////////////////////////////////////////////

// список возможных ходов 1201 + 6
//#define DELTA(d) (1+(d)) пример определения как я помню тут до фига подводных камней

// дипазон целых
//Integer.         4bytes            signed: -2147483648 to 2147483647
//                                   unsigned:         0 to 4294967295 

//const int MAX_MOVES = 80000000;
//                    
const int MAX_MOVES = 252600;
const int MAX_DEPTH = 110;

// мы знаем что char signed: -128 to 127
//---------------------------------------------------------------------------
// список возможных ходов 1201 + 6
struct T_list_surplus_moves {
////////////////////////////////////////////////////////////////////////////
// реализуем дерево перебора на слое: мы показываем: откуда ходим, куда, что за ход и
// что за фигура ходит, количество ходов.
// диапазон  int ~+-32000

// имя фигуры: 0 -нет фигуры,1 - пешка 2 - ладья 3 - конь 4 - слон 5 - ферзь 6 - король 
int name_figure[MAX_MOVES];

// начальное положение фигуры(откуда фигура ходит)
int  initial_position[MAX_MOVES]; 

// конечное положение фигуры(куда фигура ходит)
int  final_position[MAX_MOVES];

/*
int move[ListSize];

1 byte
откуда фигура ходит
0 - 63

2 byte
куда фигура ходит
0 - 63

3 byte
имя фигуры
0 - нет фигуры
1 - пешка 
2 - конь 
3 - слон
4 - ладья 
5 - ферзь 
6 - король

4 byte  
тип хода
0 - нет хода
1 – простой ход
2 – взятие
3 – длинная рокировка
4 – короткая рокировка
5 – взятие на проходе

12 - превращение в конь 
13 - превращение в слон
14 - превращение в ладья 
15 - превращение в ферзь 

22 - взятие с превращением в конь 
23 - взятие с превращением в слон
24 - взятие с превращением в ладья 
25 - взятие с превращением в ферзь 

5 byte
взятая фигура
31 - пешка 
32 - конь 
33 - слон
34 - ладья 
35 - ферзь 
36 - король

6 byte
размер списка
 0 - 255

*/
int  description_move[MAX_MOVES];

// начало списка точнее первая заполненная позиция
int  start_list[MAX_DEPTH];

// конец списка точнее первая пустая позиция
int  end_captures[MAX_DEPTH];

// конец списка точнее первая пустая позиция
int  end_list[MAX_DEPTH];
/*
пример:
0
1 запись 
2 запись 
3 запись
4
start_list здесь 1
end_list   здесь 4
*/

// текущая глубина
int  current_depth;


////////////////////////////////////////////////////////////////////////////

// эта часть нужна реализатору ходов для восстановления позиции после хода

// имя взятой фигуры 0 -нет фигуры,1 - пешка 2 - ладья 3 - конь 4 - слон 5 - ферзь 6 - король 
int  name_taking_figure[MAX_MOVES];
// флаг возврата взятия на проходе 1/0
int  return_taking_passage[MAX_DEPTH];
// флаг рокировки белых в длинную сторону
int  return_castling_Q[MAX_DEPTH];
// флаг рокировки белых в короткую сторону
int  return_castling_K[MAX_DEPTH];
// флаг рокировки черных в длинную сторону
int  return_castling_q[MAX_DEPTH];
// флаг рокировки черных в короткую сторону
int  return_castling_k[MAX_DEPTH];

};//struct T_list_surplus_moves {


////---------------------------------------------------------------------------
// линия варианта (при форсировке взятий нужно 32 полухода + 40 для основного = 72)
struct T_PV {
//// начальное положение фигуры(откуда фигура ходит)
int  initial_position[100]; 
// конечное положение фигуры(куда фигура ходит)
int  final_position[100];
// Фигура превращения пешки 0 - нету 2 - ладья 3 - конь 4 - слон 5 - ферзь 
int  final_pawn[100];

// оценка варианта
int score_move;
// длина варианта
int  depth_max;
};//struct T_PV {

//---------------------------------------------------------------------------
// реализуем хеш лучшего хода в данной позиции
struct T_hash_moves {
// хеш ключ позиции
int key;

// начальное положение фигуры(откуда фигура ходит)
int  initial_position; 

// конечное положение фигуры(куда фигура ходит)
int  final_position;

// глубина записи данного ключа
int  depth;
};//struct T_PV {

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// реализуем ход - убицу
struct T_killer_moves {

// начальное положение фигуры(откуда фигура ходит)
int  initial_position; 

// конечное положение фигуры(куда фигура ходит)
int  final_position;

};//struct T_killer_moves {

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// коллекция переменных идущих только в глубину(ПОКА НЕ ИСПОЛЬЗУЮ)
struct T_point {
int alpha;//альфа
int beta;//бета,
int depth_max;//максимальная глубина
int depth;//глубина перебора
int description_move;//тип хода
int for_chek;//флаг шаха
int null_m;//флаг нулевого хода
//int nodes;//счетчик узлов
//int br;//экстренный выход
};//struct T_killer_moves {

//---------------------------------------------------------------------------
#endif // !defined D_STRUCTURE_H






