#ifndef K_STRUCTURE_H
#define K_STRUCTURE_H


//--------------------------------------------------------------------------
/* +
 * описываем структуры
 *
 * АВТОР ChessTerminator75
 * ПОСЛЕДНЕЕ ИЗМЕНЕНИЕ 15.05.2008
*/
//--------------------------------------------------------------------------

// Bitboard

// максимум на имя фигур
const int NAME = 7;
// максимум на количество фигур одного типа и цвета
const int COORDINATE = 64;
// битовая доска
struct T_Bitboard {
//-------------------------------------------------
// доска представленна следующим образом
//A8(56) B8(57) C8(58) D8(59) E8(60) F8(61) G8(62) H8(63)
//A7(48) B7(49) C7(50) D7(51) E7(52) F7(53) G7(54) H7(55)
//A6(40) B6(41) C6(42) D6(43) E6(44) F6(45) G6(46) H6(47)
//A5(32) B5(33) C5(34) D5(35) E5(36) F5(37) G5(38) H5(39)
//A4(24) B4(25) C4(26) D4(27) E4(28) F4(29) G4(30) H4(31)
//A3(16) B3(17) C3(18) D3(19) E3(20) F3(21) G3(22) H3(23)
//A2(8)  B2(9)  C2(10) D2(11) E2(12) F2(13) G2(14) H2(15)
//A1(0)  B1(1)  C1(2)  D1(3)  E1(4)  F1(5)  G1(6)  H1(7)
//
//A1(MSB)- это нулевой бит H8(LSB)-это 63 бит
// т.е. битовая развертка выглядит следующим образом
// H8(63) G8(62) F8(61) . . . . . .C1(2) B1(1) A1(0)
//-------------------------------------------------
// ДОСКА
// в этих 64 битных переменных мы храним все белые фигуры и все черные фигуры
// конечно тут пишется только факт наличия или отсутвия фигуры в каком то поле
// причем неизвестно  что это за фигура известен только цвет по принадлежности
// к той или иной переменной
unsigned __int64  all_piece;
unsigned __int64  all_white_piece;
unsigned __int64  all_black_piece;

//-------------------------------------------------
// СПИСКИ ФИГУР
/*
 имя фигуры
 0 - нет фигуры
 1 - пешка 
 2 - конь 
 3 - слон
 4 - ладья 
 5 - ферзь 
 6 - король
*/
// битовые списки черных и белых фигур
unsigned __int64 white_piece[NAME];
unsigned __int64 black_piece[NAME];

// имя фигуры от координаты 
int white_name_from_coord[COORDINATE];
int black_name_from_coord[COORDINATE];

//-------------------------------------------------
// ВСПОМОГАТЕЛЬНАЯ ИНФОРМАЦИЯ
// цвет хода 0 - черные 1 - белые
int  colour_move;

// разрешение бития на проходе 1/0
int  taking_passage_yes;
// х координата битого поля(конвертируем из буквы) 
int  taking_passage_x;
// у координата битого поля(у нас инверсна относительно нормальной доски) 
int  taking_passage_y;

// рокировка белых в длинную сторону   1/0
int  castling_Q;
// рокировка белых в короткую сторону  1/0
int  castling_K;
// рокировка черных в длинную сторону  1/0
int  castling_q;
// рокировка черных в короткую сторону 1/0
int  castling_k;

// хеш ключ позиции(нужно? уходить от int )
int hash_key ;
// оценка позиции
int eval ;
};//struct T_Bitboard {






///////////////////////////////////////////////////////////////////////////////////

//const int MAX_MOVES = 80000000;

const int MAX_MOVES = 25600;
const int MAX_DEPTH = 100;

// мы знаем что char signed: -128 to 127
//---------------------------------------------------------------------------
// список возможных ходов 1201 + 6
struct T_list_surplus_moves {
////////////////////////////////////////////////////////////////////////////
// реализуем дерево перебора на слое: мы показываем: откуда ходим, куда, что за ход и
// что за фигура ходит, количество ходов.

int move[MAX_MOVES];

/*
в целом числе массива move мы упаковали следующую информацию (используем 27 бит)
  --3 бит--      --6 бит--   --6 бит--     --6 бит--  --6 бит-- 
 ходящая фигура  куда ходим  откуда ходим  тип хода   взятая фигура


идем справа т.е. с младшего бита
             --6 бит-- 
             взятая фигура
 31 - пешка 
 32 - конь 
 33 - слон
 34 - ладья 
 35 - ферзь 
 36 - король
 
 запись move = тип фигуры
 чтение move & 63 ( 63 это ...000111111)

            --6 бит--
            тип хода
 0 - нет хода
 1 – простой ход
 2 – взятие
 3 – длинная рокировка
 4 – короткая рокировка
 5 – взятие на проходе

 12 - превращение в конь 
 13 - превращение в слон
 14 - превращение в ладья 
 15 - превращение в ферзь 

 22 - взятие с превращением в конь 
 23 - взятие с превращением в слон
 24 - взятие с превращением в ладья 
 25 - взятие с превращением в ферзь 
 
 запись move = move & тип хода << 6
 чтение (move>>6) & 63

             --6 бит--
             откуда ходим (0 -63)
 запись move = move | (откуда ходим << 12)
 чтение (move>>12) & 63

             --6 бит--
             куда ходим (0 -63)
 запись move = move | (куда ходим << 18)
 чтение (move>>18) & 63

             --3 бит-- 
             ходящая фигура
 0 - нет фигуры
 1 - пешка 
 2 - конь 
 3 - слон
 4 - ладья 
 5 - ферзь 
 6 - король
 запись move = move | (куда ходим << 24)
 чтение (move>>24) & 7 ( 7 это ...000111)
*/

// начало списка точнее первая заполненная позиция
int  start_list[MAX_DEPTH];

// конец списка точнее первая пустая позиция
int  end_captures[MAX_DEPTH];

// конец списка точнее первая пустая позиция
int  end_list[MAX_DEPTH];
/*
пример:
0
1 запись 
2 запись 
3 запись
4
start_list здесь 1
end_list   здесь 4
*/

// текущая глубина
int  current_depth;

////////////////////////////////////////////////////////////////////////////
// эта часть нужна реализатору ходов для восстановления позиции после хода

// флаг возврата взятия на проходе 1/0
int  return_taking_passage[MAX_DEPTH];
// флаг рокировки белых в длинную сторону
int  return_castling_Q[MAX_DEPTH];
// флаг рокировки белых в короткую сторону
int  return_castling_K[MAX_DEPTH];
// флаг рокировки черных в длинную сторону
int  return_castling_q[MAX_DEPTH];
// флаг рокировки черных в короткую сторону
int  return_castling_k[MAX_DEPTH];

};//struct T_list_surplus_moves {


////---------------------------------------------------------------------------
// линия варианта (при форсировке взятий нужно 32 полухода + 40 для основного = 72)
struct T_PV {
// начальное положение фигуры(откуда фигура ходит)
int  initial_position[100]; 
// конечное положение фигуры(куда фигура ходит)
int  final_position[100];
/*
 превращение пешки
 12 - превращение в конь 
 13 - превращение в слон
 14 - превращение в ладья 
 15 - превращение в ферзь 

 22 - взятие с превращением в конь 
 23 - взятие с превращением в слон
 24 - взятие с превращением в ладья 
 25 - взятие с превращением в ферзь */
int  final_pawn[100];

// оценка варианта
int score_move;
// длина варианта
int  depth_max;
};//struct T_PV {

//---------------------------------------------------------------------------
// реализуем хеш лучшего хода в данной позиции
struct T_hash_moves {
// хеш ключ позиции
int key;

// начальное положение фигуры(откуда фигура ходит)
int  initial_position; 

// конечное положение фигуры(куда фигура ходит)
int  final_position;

// глубина записи данного ключа
int  depth;
};//struct T_PV {

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// реализуем ход - убицу
struct T_killer_moves {

// начальное положение фигуры(откуда фигура ходит)
int  initial_position; 

// конечное положение фигуры(куда фигура ходит)
int  final_position;

};//struct T_killer_moves {

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//// коллекция переменных идущих только в глубину(ПОКА НЕ ИСПОЛЬЗУЮ)
//struct T_point {
//int alpha;//альфа
//int beta;//бета,
//int depth_max;//максимальная глубина
//int depth;//глубина перебора
//int description_move;//тип хода
//int for_chek;//флаг шаха
//int null_m;//флаг нулевого хода
////int nodes;//счетчик узлов
////int br;//экстренный выход
//};//struct T_killer_moves {

//---------------------------------------------------------------------------
#endif // !defined D_STRUCTURE_H






