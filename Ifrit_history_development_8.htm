<!DOCTYPE html>
<html>

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <!-- Copyright (c) 2006-2019, Brenkman Andrey and/or its affiliates. All rights reserved. -->
 <title>Дневник разработчика шахматной программы часть 6</title>
</head>

<body>

<table border="0" cellspacing="10" width="100%" id="AutoNumber1"  bgcolor="#CCCCFF">
  <tr>
    <td width="100%">
    <table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber2">
      <tr>
        <td width="75%">
    <h2 align="center">Ifrit </h2>
    <h2 align="center">История разработки.</h2>
        </td>
        <td width="25%">
        <p align="left"><a href="/Ifrit_chess_engine/index.html">на главную страницу</a></td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td width="100%">
      <p class="MsoNormal" align="left"><span style="font-size:14.0pt">&nbsp;<br>
      <a href="Ifrit_history_development_7.htm">Ifrit_<span lang="en-us">j</span> История разработки. <br >
      Часть 7 </a>
      </p>

  
      </span>

<font size="4">

      <p align="left">Ifrit<br>
      Часть 8<br>
      &nbsp;</p>
      <p>Опубликованная версия Ifrit_j3_4</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 17 июля 2010 г.</p>
      <p>Следующей версии не будет, если она не станет сильнее. Как же мне ее 
      усиливать?</p>
      <p>1. Это оценка. Совершенно непонятно насколько она адекватна.</p>
      <p>2. Это поиск. Нет ли в нем ошибок, которые серьезно срезают силу игры?</p>
      <p>3. Возможно, что этот набор эвристик не может давать лучший результат и 
      следует добавлять новые.</p>
      <font SIZE="2">
      <p></p>
      </font>
      <p>Первое время я думал, что дело в скорости перебора. Скорость конечно 
      очень важна, но тут дело не только в ней.</p>
      <p>Нулевой ход не может дать такой глубины. Это очевидно и ясно 
      иллюстрируется глубиной программ, использующих только нулевой ход.</p>
      <p>Потом я думал, что дело в ЛМР. Это очень мощная эвристика но, похоже, 
      дело не только в ней.</p>
      <p>Возможно, дело в эффективной отсечке по оценке из хеш-таблицы. Либо 
      есть еще, какие-то отсечки, которые я пропустил.</p>
      <p>В целом можно сказать, что все дело в отсечках. Надо понять, какие 
      отсечки я пропустил или возможно у меня плохо работают.</p>
      <p>Дальше следует сказать о продлениях. У меня только на шахе. Видимо 
      этого мало.</p>
      <p>Ну и конечно корневой поиск. Возможно, это именно то место, которое у 
      меня сильно недоработано.</p>
      <p>Еще надо выяснить, какое значение имеет продления на шахе в статическом 
      поиске.</p>
      <p>А возможно, что у меня везде хуже и эффект суммируется приводя к 
      катастрофе.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Четверг, 22 июля 2010 г.</p>
      <p>Все попытки усилить программу окончились ничем. </p>
      <p>Пробовал включать продления на разменах во всех линиях. Но это только 
      затормозило поиск. И в острых тактических позициях программа так же 
      пропускает удары. Видимо, lmr делает эти продления бессмысленными. Что 
      толку смотреть вариант глубже, если мы в самом начале пропускаем тихий 
      опровергающий ход. То же самое и для продлений только в главном варианте.</p>
      <p>В игре случился откровенно проигрывающий ход. Воспроизвести его я не 
      смог. Может это из-за отсечки по времени, а может еще что.</p>
      <p>Снова и снова ловлю себя на мысли, что я не доверяю коду. У меня не 
      получается сделать достаточно протестированную программу. Внутри нет 
      достаточной модульности. Слишком все перемешано.</p>
      <p>Много всяких строчек и правильно ли они работают непонятно - так можно 
      обобщить мои сомнения. Способ борьбы с этим придумали уже давно. Это 
      функции. Эти строчки должны работать на функцию и тестировать мы должны 
      функцию. Все проблемы возникают, если я недостаточно придерживаюсь этого 
      правила, либо неправильно разбиваю строчки на функции.</p>
      <p>Каждая функция должна решать одну определенную задачу. Подзадачи внутри 
      сложных функций должны решать другие функции. Таким образом, 
      сколько-нибудь сложные функции это композиция более простых функций.</p>
      <p>Функция должна иметь средства самоконтроля, работающие в тестовом 
      режиме.</p>
      <p>Все это прописные истины, но даже их я умудряюсь нарушать! Понятно, что 
      в таком случае не приходится говорить о надежности кода.</p>
      <p>Совершенно недопустимо множество строчек, следующих друг за другом и 
      решающих разные задачи. А у меня это встречается повсеместно.</p>
      <p>Такое можно допустить только в функциях, которые требуют максимальной 
      скорости и которые можно максимально протестировать. Примером может 
      служить генератор ходов.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 24 июля 2010 г.</p>
      <p>Продолжаю битву за рейтинг. Надо сказать, что это достаточно занудное 
      занятие. Сейчас занимаюсь отсечками. Но пока результат крайне 
      сомнительный.</p>
      <p>Также понял, что в оценке неправильно положение фигуры ценить меньше, 
      чем положение пешки. Это приводит к необеспеченному штурму пешками. Как 
      правило, такой штурм терпит поражение. Оценку надо будет подправить.</p>
      <p>Одолевают сомнения по поводу шаха в статическом поиске. Насколько он 
      там нужен? Но прежде чем его туда добавлять, необходимо будет дописать 
      уклонения от шахов, что несколько усложнит программу. Зато это позволит 
      использовать продления на единственном ходе.</p>
      <p>Исправил ошибочный ход при отсечке поиска по времени. В блице это очень 
      даже вредная ошибка.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия Ifrit_j3_5</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Четверг, 29 июля 2010 г.</p>
      <p>Ста пунктов прибавки, видимо, нет. Впредь не стоит бросаться такими 
      заявлениями. Теперь надо настроить отсечки. Продолжать тестировать и 
      совершенствовать код. </p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия Ifrit_j3_6</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Четверг, 2 сентября 2010 г.</p>
      <p>После выпуска версии 3.6 ничего не делал. Для повышения рейтинга я 
      больше ничего делать не буду. У меня нет цели добиться высокого рейтинга. 
      Рейтинг - это только показатель качества поиска и не более того. </p>
      <p>Обдумывал уклонения при шахе. Получается как-то сложно и коряво. 
      Непонятно даже будет ли он быстрее обычного поиска. И даже если признать, 
      что он будет быстрее то насколько? В любом случае разнится только в 
      скорости обработки шахов.</p>
      <p>Хотел вернуть сортировку по истории. Но когда начал делать как-то 
      энтузиазм пропал. Мои тесты показывали, что выгоды от моей реализации 
      никакой. Так зачем возвращать бесполезную вещь?</p>
      <p>Эти две эвристики только усложняют код. И даже если прирост есть, 
      по-моему, он не стоит той сложности, которая при этом добавляется.</p>
      <font SIZE="2">
      <p></p>
      </font>
      <p>Еще можно добавить шахи в статический поиск. Но тут тоже, по-моему, 
      слишком сложно получается.</p>
      <p>Оценка меня тем более не вдохновляет :)</p>
      <p>Вот так получается, что пока я ничего не делаю.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Вторник, 14 сентября 2010 г.</p>
      <p>Все еще ничего не делаю. Причина простоя в том, что я не хочу больше 
      ничего добавлять в код.</p>
      <p>Очевидно, что есть много что можно добавить в код, но я не хочу. Есть 
      внутреннее сопротивление. Такое чувство, что при этом код превращается в 
      свалку.</p>
      <p>Еще раз скажу. Мне нужен код, который будет хорошо структурирован, 
      хорошо прокомментирован, хорошо протестирован. Он должен быть понятен. А 
      сила игры это не цель, это приятный бонус. </p>
      <p>В последней версии в итоге отвлеченности на рейтинг меня сильно 
      переклинило. Так что даже я не смог заниматься кодом дальше.</p>
      <p>Сейчас я возвращаюсь на прежний курс. Т.е. буду тестировать и 
      комментировать. :)</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Воскресенье, 19 сентября 2010 г.</p>
      <p>Когда идет атака на короля движок тупит. И вообще игра производит 
      странное впечатление. Что-то в поиске сильно не то. Самое неприятное, что 
      во время анализа партии часто движок не повторяет своего хода на той же 
      глубине. Такую нестабильность считаю недопустимой. Также следует выяснить, 
      в чем причины провалов по глубине в матче, который проводил Graham.</p>
      <p>Я недоволен кодом. Слишком запутан и плохо протестирован. Это 
      постоянная проблема и пока мне не удалось ее решить. Я должен быть уверен 
      в коде, а этого нет. Код должен быть понятен для любого программиста, а не 
      только того, кто в теме. Этого тоже нет.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 2 октября 2010 г.</p>
      <p>После перерыва продолжаю разработку программы. Многое забыл так, что 
      сейчас пришло время посмотреть на код свежим взглядом и сделать его более 
      читаемым и понятным. Сейчас главное не увязнуть в мелочах, а обдумать 
      ситуацию в целом, по-новому все оценить.</p>
      <p>Может, все-таки получится написать внятные комментарии. Нужно 
      попытаться непредвзято посмотреть на код и его слабые места. Как их 
      прикрыть это уже второй вопрос. Нужно написать паспорт на программу с 
      полным описанием логики работы и методики тестирования.</p>
      <p>Сделать код надежным и понятным. В этих словах бездна работы и 
      понимания.</p>
      <p>Сравнительно слабая игра программы может быть вызвана двумя причинами. 
      Первое - это неудачная, т.е. медленная и нестабильная реализация эвристик. 
      И второе - это отсутствие необходимых для такого уровня игры эвристик.</p>
      <p>Сейчас хочется поразмышлять о глобальных вещах. О методах и концепциях. 
      Не плодить нового, а разобраться в том, что есть - что могут дать 
      реализованные эвристики, и насколько хорошо они реализованы у меня.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Понедельник, 4 октября 2010 г.</p>
      <p>Каждая функция должна решать одну определенную задачу. Подзадачи внутри 
      сложных функций должны решать другие функции. Таким образом, 
      сколько-нибудь сложная функция - это композиция более простых функций.</p>
      <p>Попытка следовать этой рекомендации порождает проблему параметров. Их 
      становится слишком много. И это само по себе становится проблемой и 
      источником ошибок.</p>
      <p>Уйти от параметров можно через глобальные переменные. Но тогда 
      становится непонятным, с чем работает функция.</p>
      <p>Обдумывание концепций пока ни к чему не приводит.</p>
      <p>Смотрю на код поиска и не вижу системы. Непонятно, действительно ли 
      функции должны быть такими и такое количество. В общем, не хватает 
      обоснования структуры. Нужно как-то показать какая структура наиболее 
      оптимальная. Показать что все на своем месте.</p>
      <p>Я достаточно давно занимаюсь написанием шахматной программы, так что 
      представляю себе, что это такое. Знаний и материала в данный момент мне 
      хватает. Непроработана именно система. Нужно этот материал как-то 
      упорядочить.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Вторник, 5 октября 2010 г.</p>
      <p>Во многих функциях поиска огромное количество параметров. Так ли они 
      необходимы? </p>
      <p>Обдумываю системный подход. Пока безрезультатно.</p>
      <p>Вроде код написан аккуратно, а все равно непонятно. Также непонятно, 
      правильно ли он работает или где-то закрались ошибки.</p>
      <p>Надо думать, как с этим справиться.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 9 октября 2010 г.</p>
      <p>Третий день экспериментирую с хеш-таблицей. Сначала пытался вернуться к 
      одному ключу и для ходов и для оценки. В итоге все перестало работать. 
      Думаю, главная проблема в том, что разные ключи пытаются поместиться в 
      одну ячейку таблицы. Это происходит потому, что размер таблицы ограничен, 
      и мы колоссальное множество возможных 64 битных чисел пытаемся разместить 
      в маленьком пространстве.</p>
      <p>В итоге вернулся к разным ключам для лучших ходов и оценок.</p>
      <p>Дальше опять вернулся к одному ключу. Разницы не увидел. Так что 
      оставлю один ключ - так проще. Дальше можно попробовать кластерную запись.</p>
      <p>Отключил часть разоринга. По-моему, я два раза делал одно и то же.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Воскресенье, 10 октября 2010 г.</p>
      <p>Вернулся к двум ключам. Запись хода для сортировки и оценки отличаются. 
      Ход для сортировки следует перезаписывать поверх предыдущих поисков. Иначе 
      таблица засоряется, и ровный ход итераций нарушается. Это же можно сказать 
      о влиянии предыдущего поиска. Так что сортировку следует записывать по 
      большей глубине только для текущих итераций, а прошлые позиции всегда 
      следует перезаписывать для всех, даже для таких же позиций. Если не ясно 
      про что я говорю, то посмотрите код. Яснее объяснить не получается.</p>
      <p>Для оценок же такая тактика обесценивает сам метод.</p>
      <p>Упростил и слегка подправил futility pruning. Очевидно, что моя 
      реализация была избыточна.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия Ifrit_j3_7</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Пятница, 29 октября 2010 г.</p>
      <p>Вопросы модульности и тестирования остаются открытыми. Надо добиваться 
      максимальной инкапсуляции и связанности. Все модули и алгоритмы должны 
      быть прокомментированы. В начале модуля следует полностью описать теорию и 
      особенности реализации. Счет должен быть прозрачным и максимально 
      протестированным. В нем везде должны быть функции самотестирования. </p>
      <p>Конечно, я далек от реализации этих пожеланий. Но постараюсь двигаться 
      в этом направлении.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Среда, 3 ноября 2010 г.</p>
      <p>Опять вернулся к идеологии. Хочется привести программу к обоснованному 
      виду. Чтобы все ее части были на своем месте и действительно нужны. Кроме 
      того, они должны быть оптимальны, и правильно работать.</p>
      <p>Нужно ли все значения, используемые в функции протаскивать как 
      параметры или можно использовать глобальные в пределах модуля? Я понимаю, 
      что это занудство, но в данный момент меня интересует именно способ 
      построения максимально надежного и протестированного решения. И в данный 
      момент непонятно что для этого нужно.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Четверг, 4 ноября 2010 г.</p>
      <p>Начнем с самого начала.</p>
      <p>Основа программы - это набор данных, с которыми производятся 
      определенные манипуляции.</p>
      <p>Для того, что бы программа была понятна, прежде всего, переменные 
      должны иметь осмысленные имена, выражающие их суть.</p>
      <p>Но просто множество переменных, пусть даже и с осмысленными именами, 
      как правило, слишком большое и приходится каждый раз перебирать все, 
      прежде чем найдешь нужную. Поэтому мы вводим уровень абстракции, такой как 
      структура или класс. Тогда становится понятно, где искать нужную 
      переменную, и в какую структуру она входит.</p>
      <p>Таким образом, чтобы программа была понятная, данные должны иметь 
      осмысленные имена и объединяться в осмысленные структуры.</p>
      <p>Тогда их легко находить, и понятно для чего они нужны.</p>
      <p>Теперь, если мы примем, что данные и их обработчики должны быть 
      объединены, то мы придем к объектному программированию.</p>
      <p>Программа должна быть тестируемой и структурированной. Это значит, что 
      каждый этап должен заканчиваться четко очерченным набором данных, который 
      можно просмотреть и распечатать. Другими словами, ядром каждого 
      функционального этапа должен быть объект. </p>
      <p>И так еще раз. Каждый этап работы программы должен иметь четко 
      очерченный результат, поддающийся проверке. Другими словами, каждый этап 
      реализует некоторая структура и методы заполняющие ее. Так я понимаю 
      объект в данном случае.</p>
      <p>Я окончательно забросил идею переписать всю программу на ассемблере. А 
      это значит, что я вновь перехожу к классам и отказываюсь от извращения, 
      когда роль классов выполняло пространство имен.</p>
      <p>Переписывать всю программу на ассемблере это колоссальный труд, который 
      на данном этапе неуместен. Кроме того, и это самое главное, теряется 
      ценность открытого исходного кода, потому что ассемблер почти никто не 
      знает и такой уровень детализации, как правило, неприменим в других 
      программах.</p>
      <p>Итогом всего вышесказанного будет то, что я попытаюсь привести 
      программу в соответствие с нормой объектно-ориентированного 
      программирования. Надеюсь, что программа станет понятной и тестируемой.</p>
      <p>Только сейчас до меня стала доходить красота и гениальность 
      объектно-ориентированного подхода. Я давно знал этот подход, но не понимал 
      его.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 20 ноября 2010 г.</p>
      <p>Попытки переписать программу закончились провалом. Выявилось множество 
      препятствий. Классы получаются слишком большие с включением чуждых друг 
      другу эвристик. </p>
      <p>Дело в том, что данных мало, а функций много. Преобразование оказалось 
      сложнее, чем я думал.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия Ifrit_j3_8</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Воскресенье, 5 декабря 2010 г.</p>
      <p>Начал переход на объектную модель. В версии 3.8 сделал классы списка 
      ходов и доски. Что делать дальше пока не знаю. Главный приоритет это 
      тестируемость кода. Т.е. тестируемость всех эвристик. Сосредоточусь на 
      этом. Нужно разбить программу на тестируемые модули и этапы.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия Ifrit_j3_9</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Четверг, 16 декабря 2010 г.</p>
      <p>Некоторые вопросы, на которые хочется получить ответ.</p>
      <p>Можно ли усилить движок без добавления новых эвристик? </p>
      <p>Настоящий уровень - это потолок данной реализации или силу срезают 
      ошибки?</p>
      <p>Как разбить программу на изолированные модули?</p>
      <p>Как максимально полно ее протестировать?</p>
      <p>Как ее оптимизировать?</p>
      <p>Нужны объективные критерии, а не мнения.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия Ifrit_j4_0</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Воскресенье, 26 декабря 2010 г.</p>
      <p>Заменил все указатели на ссылки. Точнее почти все. Указатель на 
      динамически выделенную память заменить не смог. Он используется в 
      реализации хеш-таблицы. Я просто обложил этот указатель проверками.</p>
      <p>Зачем я эта замена? Все-таки ссылки надежнее. Никогда не знаешь, откуда 
      вылезет неадекватный указатель и как он образуется. Так что лучше решить 
      проблему как класс.</p>
      <p>Для этого пришлось переписать модули, в которых использовались 
      указатели. Особенно много переделал в модулях обрабатывающих команды в 
      формате протокола UCI.</p>
      <p>Сейчас цель не усилить код, а сделать его более надежным и понятным. 
      Сомнительных мест все еще больше, чем хотелось бы.</p>
      <p>Следует собрать в модулях все им принадлежащее, включая тесты. Убрать 
      дублирование. Переписать запутанные места. Все должно тестироваться.</p>
      <p>Думаю, что стоит уйти от создания структур и объектов внутри итераций.</p>
      <p>Такой модуль как утиль показывает на недостаточную продуманность 
      структуры проекта. Он еще приемлем в структурной программе, но в объектной 
      ему делать нечего. Он ликвидирован.</p>
      <p>Сильно не нравиться хаос в переменных внутри функций. Особенно в 
      модулях поиска. Я уже сам не скажу что там и для чего. В них обязательно 
      наведу порядок. Понятные данные это обязательное условие понятности кода.</p>
      <p>Перепишу статическую оценку. А может быть, просто допишу. Но так я ее 
      не оставлю. В данный момент она неудовлетворительна.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Четверг, 30 декабря 2010 г.</p>
      <p>Модули должны взаимодействовать друг с другом только через четко 
      определенные интерфейсы. Глобальные переменные неуместны.</p>
      <p>Неясно только, что делать с классами. Использовать extern или нет.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Пятница, 31 декабря 2010 г.</p>
      <p>Вопрос о том, что передавать в параметрах функций остается открытым. 
      Передавать объекты по ссылке в параметрах или делать это через extern? </p>
      <p>Делать классы полем класса или нет? Или оставить классы глобальными, 
      т.е. всех на одном уровне. Но тогда объекты не должны создаваться внутри 
      функций и все должны быть глобальными.</p>
      <p>Все относящееся к определенной эвристики должно находиться в классе 
      этой эвристики. Каждой эвристике должен соответствовать свой класс и свой 
      модуль. Каждый класс должен находиться в отдельном модуле. Названия класса 
      и модуля должны совпадать.</p>
      <p>Видимо, полями класса можно делать только те данные, которые изменяются 
      в данном классе, т.е. они не могут быть константами. И так то, что не 
      меняется должно быть константой и константа не должна быть полем класса. 
      Это философский вопрос самоидентичности класса. Как класс отличает себя от 
      иного.</p>
      <p>К тому же, класс не должен изменять внешних себе данных. Т.е. входные 
      данные должны быть константами. Получается, что данные, которые функция 
      меняет, не должны находиться в параметрах. Потому что это по определению 
      поля класса. Хотя непонятно как быть в случае, когда одна функция вызывает 
      другую для своих внутренних нужд. Не тащить же все переменные в поля 
      класса!</p>
      <p>Что такое класс? Это связанные данные плюс функции обработки этих 
      данных. Связанность данных может быть ассоциативной, а может быть 
      предметной или еще какой-нибудь.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 1 января 2011 г.</p>
      <p>Необходимо следовать принципу один объект – одна задача. Снижение 
      связанности один из главных приоритетов. Главный вопрос, который нужно 
      решить использовать ли глобальные классы.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия Ifrit_j4_1</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Пятница, 7 января 2011 г.</p>
      <p>Ифрит играет заметно слабее, чем должен. Надо выяснить, в чем дело и 
      исправить ситуацию.</p>
      <p>Переписать оценку. Возможно, дело не в ней, но все-таки ее нужно 
      довести до ума.</p>
      <p>Прокомментировать и протестировать все классы. </p>
      <p>Продолжить оптимизацию архитектуры.</p>
      <p>Продолжить оптимизацию классов.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 8 января 2011 г.</p>
      <p>Пройдусь по всему коду и наведу порядок. Хочется добавить нового, но 
      дело в том, что старое пока далеко от нужного уровня. </p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Понедельник, 10 января 2011 г.</p>
      <p>Прошелся по поиску. Крайне тяжелое впечатление. Куча всего. И в этой 
      куче не видно главной идеи. Кроме того, непонятно как это тестировать. 
      Непонятно какие ошибки привносят разные эвристики. Как они влияют друг на 
      друга.</p>
      <p>Центральный вопрос, - как тестировать каждую эвристику, - остается без 
      ответа.</p>
      <p>Если генератор я смог протестировать, то все остальное крайне 
      ненадежно. Можно сказать больше - я не уверен, что вообще поиск ведется 
      правильно. Что сама идея не устарела.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Среда, 12 января 2011 г.</p>
      <p>Начал переписывать поиск. Очевидно, что это надо было сделать раньше. 
      Слишком давно я ничего не менял.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия Ifrit_j4_2</p>
      <p>Опубликованная версия Ifrit_j4_3</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Понедельник, 7 марта 2011 г.</p>
      <p>Необходимо сделать нормальную оценку.</p>
      <p>В архитектуре остановился на модели множества глобальных классов. 
      Конечно, это не совсем объектно-ориентированная модель, но тут этого 
      достаточно. Мне кажется, что наследование в данном случае лишне.</p>
      <p>Вопрос тестирования и оптимизации поиска остается нерешенным. Но сейчас 
      нужно сосредоточится на оценке. Как показала практика, хороший поиск не 
      компенсирует плохую оценку. Доходит до нонсенса, когда программа сама 
      заходит в безнадежные позиции.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 12 марта 2011 г.</p>
      <p>Почти весь февраль и сегодня включительно не притрагивался к коду. 
      Почему-то как только я добираюсь до оценки, так сразу работа встает.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 9 апреля 2011 г.</p>
      <p>К коду все еще не притрагивался. Пауза начала затягиваться. Пропал 
      интерес. За это время многое забылось и придется вспоминать по-новой.</p>
      <p>Адекватного тестирования создать не удалось. </p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 30 апреля 2011 г.</p>
      <p>Код не открывал. Февраль, март, апрель. Три месяца ничего не делал в 
      шахматном программировании. Заглох я на оценке. А сейчас даже грузиться 
      неохота. </p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 30 июля 2011 г.</p>
      <p>Интересно получилось, что пишу опять 30-го. И уже четвертую субботу 
      подряд! </p>
      <p>Переустановил операционную систему и теперь опять перешел на 8 студию, 
      потому что по 10 бете кончился ключ. С последней записи программой не 
      занимался. </p>
      <p>Февраль, март, апрель, май, июнь, июль ничего не делал! Слишком грузят 
      на работе. Сил на программу уже не остается.</p>
      <p>Я до сих пор не знаю, как сделать полностью прозрачный самоочевидный и 
      протестированный код. До сих пор не знаю, как сделать грамотную оценку.</p>
      <p>Так как застой очевиден, то решил сделать описание программы. В нем 
      изложу все, что я на сегодня понял и сделал. Скорее всего, в ней будет 
      все, что я до этого уже описывал, но более систематически. Хотелось бы, 
      что бы код был понятен без внешнего описания, но так не получается.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Пятница, 5 августа 2011 г.</p>
      <p>До реализации функции следует помещать теорию, которая нашла реализацию 
      в данной функции. А в заголовочном файле помещать назначение функции и ее 
      аргументов. Потребителя функции не интересует способ реализации. Его 
      интересуют возможности функции, а так же что требуется для ее 
      использования. А того, кто полез в тело функции интересует, прежде всего, 
      что там реализовано, а уже потом как это реализовано.</p>
      <p>Функций в программе тысячи, а то и сотни тысяч. Находить нужную 
      перебором просто неуместно. Они должны быть сгруппированы в более крупные 
      смысловые единицы. Понятно, что я говорю о классах и модулях. Модуль это 
      сборище однотипных функций. Также как и библиотека.</p>
      <p>Класс это объединение данных и обрабатывающих их методов. Основной плюс 
      в том, что все функции, которые могли изменить данные, собраны вместе. Это 
      принципиально. Описание класса - это, прежде всего, обоснование структуры 
      его полей. А функции-методы зависят от структуры полей, потому что они 
      служат для обработки этих полей.</p>
      <p>Описывая структуру программы, мы должны объяснить, почему мы 
      использовали именно эти переменные и почему мы разбили их именно таким 
      способом. Первый закон объектной инкапсуляции заключается в том, что 
      методы одного класса не при каких условиях не должны напрямую менять 
      данных другого класса.</p>
      <p>Надо будет проверить код Ифрита на соответствие этому принципу. 
      Конкретно это значит, что параметры методов должны быть константами. Также 
      надо будет провести обоснование текущего деления переменных на классы. 
      Описание класса это, прежде всего описание его полей.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 6 августа 2011 г.</p>
      <p>В основе кода должно быть тестирование. Если метод нельзя 
      протестировать, то такой метод не годится. Можно группироваться вокруг 
      данных. А можно вокруг методов. Это либо объектная, либо структурная 
      парадигма.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Пятница, 19 августа 2011 г.</p>
      <p>Константы разместил в пространствах имен. Получились структуры из 
      констант. Что такое классы? Это определенное множество переменных и 
      функций для работы с ними. Внешние функции не могут работать с переменными 
      класса. Внутренняя связанность в классе должна быть на порядок выше 
      внешней, т.е. между классами. В Ифрите это не удается сделать в случае 
      классов шахматной доски и списка ходов. Видимо, где-то разбиение не 
      точное.</p>
      <p>Работа с оценкой отчаянно тормозит. Это какая-то точка замерзания. 
      Поэтому пока буду описывать классы и методы.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 20 августа 2011 г.</p>
      <p>Решил тестирование положить в основу. Методически это принципиальный 
      момент. Раньше приоритетом была прозрачность структуры. Однако в итоге 
      стало ясно что, вообще говоря, никакая прозрачность не спасает от ошибок. 
      Только адекватное тестирование в состоянии помочь. Таким образом, будет 
      дан старт новой линейке Ifrit_t</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Среда, 24 августа 2011 г.</p>
      <p>Пока что мне не удается в достаточной мере развести эвристики. Они 
      слишком связанны друг с другом.</p>
      <p>Добавление новых эвристик не должно влиять на предыдущую 
      протестированную часть. Например, включение альфа-беты не должно менять 
      полного перебора. Тут надо еще подумать. Включение сортировки не должно 
      менять полного перебора. Этого я вроде добился. Даже дебильный перебор не 
      влияет на поиск, разве что притормаживает его.</p>
      <p>Принцип реализации довольно простой. Каждая эвристика - это отдельный 
      класс и отдельный модуль. Так что ни переменные, ни методы не 
      перемешиваются. Они живут отдельно, и отключить эвристику можно, просто 
      отключив объект. Нужно провести принцип строгой инкапсуляции классов и 
      эвристик. Любое использование эвристики допустимо только через объект этой 
      эвристики.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 27 августа 2011 г.</p>
      <p>Функции поиска все еще слишком сложные. В них много постороннего и 
      непонятно как это тестировать. Думаю, что надо уходить от флагов. Правда, 
      тогда непонятно как это все тестировать. Хотя тут правильный принцип, что 
      новая функциональность в новой функции.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Суббота, 3 сентября 2011 г.</p>
      <p>Продолжаю поиск наиболее подходящей структуры и метода. В основу 
      положено тестирование. Функция остается главным кирпичиком. Однако в 
      классе функция меняет глобальные переменные, которые не проходят через ее 
      параметры. Очевидно, что инкапсуляция такой функции нарушена, и ее 
      невозможно протестировать отдельно.</p>
      <p>Однако преимущества класса слишком велики. Так что минимальная 
      тестируемая единица будет именно объект.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Понедельник, 5 сентября 2011 г.</p>
      <p>Все-таки объектная модель не подходит к шахматной программе. Данных 
      мало, а обработчиков много. Так что выделю структуры, а классы будут 
      просто контейнерами функций. Основа будет в функционале.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия Ifrit_j4_4</p>
      <p>Опубликованная версия Ifrit_m1</p>
      <p>Опубликованная версия Ifrit_m1_1</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Вторник, 20 сентября 2011 г.</p>
      <p>В новых версиях добавил magic-bitboards, mobility и атаку на короля.</p>
      <p>Планирую добавить уклонения при шахе. На основе этого сингл - 
      продление. Шахи в статический поиск.</p>
      <p>Можно еще раз попробовать IID. Добавить оценку структуры пешек. Можно 
      попытаться разобраться с SSE.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия Ifrit_m1</p>
      <p>Опубликованная версия Ifrit_m1_2</p>
      <p>Опубликованная версия Ifrit_m1_3</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Вторник, 27 сентября 2011 г.</p>
      <p>Переписал генератор атак под магию. Переписал детектор шахов под магию. 
      Добавил лмр в корневой узел. Добавил обрезку по количеству узлов. Но она 
      не работает. Добавил в оценку некоторые коэффициенты из Стрелки. Играет 
      лучше, но я ожидал большего.</p>
      <p>По тактике версия с футилити лучшая. С разорингом очень глубокая, но 
      много пропускает. А с обрезкой по количеству узлов какая-то тупая.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия Ifrit_m1_4</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Четверг, 29 сентября 2011 г.</p>
      <p>Что бы побеждать, нужно смотреть глубже и смотреть точнее. Т.е. нужна 
      правильная позиционная оценка. Нужен быстрый поиск, чтобы считать на 
      большую глубину. И нужно отсекаться, так что бы считать глубже, но при 
      этом не отсекать лишнего.</p>
      <p>И так считать нужно как можно быстрее и как можно полнее. Конечно это 
      противоречивые требования. Так же как отсекать нужно, как можно больше, но 
      при этом нельзя отсекать лишнее.</p>
      <p>
      _______________________________________________________________________________________________</p>
      <p>Опубликованная версия Ifrit_m1_4</p>
      <p>
      _______________________________________________________________________________________________</tr>
</table>
<p align="left">&nbsp;</p>
</font>
</body>